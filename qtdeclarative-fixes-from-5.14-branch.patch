diff --git a/examples/quick/scenegraph/d3d11underqml/d3d11underqml.pro b/examples/quick/scenegraph/d3d11underqml/d3d11underqml.pro
index 3c94d48ac..7658a9a81 100644
--- a/examples/quick/scenegraph/d3d11underqml/d3d11underqml.pro
+++ b/examples/quick/scenegraph/d3d11underqml/d3d11underqml.pro
@@ -1,3 +1,5 @@
+!win32: error("This example requires Windows")
+
 QT += qml quick
 
 HEADERS += d3d11squircle.h
diff --git a/examples/quick/scenegraph/metaltextureimport/metaltextureimport.pro b/examples/quick/scenegraph/metaltextureimport/metaltextureimport.pro
index c8ea7ce47..5b1160694 100644
--- a/examples/quick/scenegraph/metaltextureimport/metaltextureimport.pro
+++ b/examples/quick/scenegraph/metaltextureimport/metaltextureimport.pro
@@ -1,3 +1,5 @@
+!macos: error("This example requires macOS")
+
 QT += qml quick
 
 HEADERS += metaltextureimport.h
diff --git a/examples/quick/scenegraph/metalunderqml/metalunderqml.pro b/examples/quick/scenegraph/metalunderqml/metalunderqml.pro
index 9b27638a6..9fd131fe1 100644
--- a/examples/quick/scenegraph/metalunderqml/metalunderqml.pro
+++ b/examples/quick/scenegraph/metalunderqml/metalunderqml.pro
@@ -1,3 +1,5 @@
+!macos: error("This example requires macOS")
+
 QT += qml quick
 
 HEADERS += metalsquircle.h
diff --git a/examples/quick/scenegraph/rendernode/customrenderitem.cpp b/examples/quick/scenegraph/rendernode/customrenderitem.cpp
index 8aaa56c35..e55cf0a2f 100644
--- a/examples/quick/scenegraph/rendernode/customrenderitem.cpp
+++ b/examples/quick/scenegraph/rendernode/customrenderitem.cpp
@@ -87,7 +87,9 @@ QSGNode *CustomRenderItem::updatePaintNode(QSGNode *node, UpdatePaintNodeData *)
         break;
 
     case QSGRendererInterface::MetalRhi:
-#ifdef Q_OS_DARWIN
+// Restore when QTBUG-78580 is done and the .pro is updated accordingly
+//#ifdef Q_OS_DARWIN
+#ifdef Q_OS_MACOS
         if (!n) {
             MetalRenderNode *metalNode = new MetalRenderNode;
             n = metalNode;
diff --git a/examples/quick/scenegraph/rendernode/metalrenderer.h b/examples/quick/scenegraph/rendernode/metalrenderer.h
index 31387a0e2..cf7fccb93 100644
--- a/examples/quick/scenegraph/rendernode/metalrenderer.h
+++ b/examples/quick/scenegraph/rendernode/metalrenderer.h
@@ -54,7 +54,8 @@
 #include <qsgrendernode.h>
 #include <QQuickItem>
 
-#ifdef Q_OS_DARWIN
+//#ifdef Q_OS_DARWIN
+#ifdef Q_OS_MACOS
 
 QT_BEGIN_NAMESPACE
 
diff --git a/examples/quick/scenegraph/vulkanunderqml/vulkanunderqml.pro b/examples/quick/scenegraph/vulkanunderqml/vulkanunderqml.pro
index 9a0a87c9f..9ea57b91c 100644
--- a/examples/quick/scenegraph/vulkanunderqml/vulkanunderqml.pro
+++ b/examples/quick/scenegraph/vulkanunderqml/vulkanunderqml.pro
@@ -1,3 +1,5 @@
+!qtConfig(vulkan): error("This example requires Qt built with Vulkan support")
+
 QT += qml quick
 
 HEADERS += vulkansquircle.h
diff --git a/examples/quick/views/doc/src/views.qdoc b/examples/quick/views/doc/src/views.qdoc
index 294b88542..3e23f7657 100644
--- a/examples/quick/views/doc/src/views.qdoc
+++ b/examples/quick/views/doc/src/views.qdoc
@@ -39,13 +39,13 @@
 
     \include examples-run.qdocinc
 
-    \section1 GridView and PathView
+    \section1 Using GridView and PathView
 
     \e GridView and \e PathView demonstrate usage of these types to display
     views.
     \snippet views/gridview/gridview-example.qml 0
 
-    \section1 Dynamic List
+    \section1 Using Dynamic List
 
     \e{Dynamic List} demonstrates animation of runtime additions and removals to
     a \l ListView.
@@ -66,12 +66,12 @@
     \snippet views/listview/expandingdelegates.qml 2
     \snippet views/listview/expandingdelegates.qml 3
 
-    \section1 Highlight
+    \section1 Using Highlight
 
     \e Highlight demonstrates adding a custom highlight to a ListView.
     \snippet views/listview/highlight.qml 0
 
-    \section1 Highlight Ranges
+    \section1 Using Highlight Ranges
 
     \e{Highlight Ranges} shows the three different highlight range modes of
     ListView.
@@ -79,15 +79,15 @@
     \snippet views/listview/highlightranges.qml 1
     \snippet views/listview/highlightranges.qml 2
 
-    \section1 Sections
+    \section1 Using Sections
 
     \e Sections demonstrates the various section headers and footers available
     to \l ListView.
     \snippet views/listview/sections.qml 0
 
-    \section1 Packages
+    \section1 Using Packages
 
-    \e Packages uses the \l Package type to transition delegates between
+    \e Packages use the \l [QML]{Package} type to transition delegates between
     two views.
 
     It has a Package object which defines delegate items for each view and an
@@ -100,13 +100,13 @@
 
     \snippet views/package/view.qml 0
 
-    \section1 ObjectModel
+    \section1 Using ObjectModel
 
     \e ObjectModel uses an ObjectModel for the model instead of a \l ListModel.
 
     \snippet views/objectmodel/objectmodel.qml 0
 
-    \section1 Display Margins
+    \section1 Using Display Margins
 
     \e{Display Margins} uses delegates to display items and implements a simple
     header and footer components.
diff --git a/src/imports/layouts/qquickstacklayout.cpp b/src/imports/layouts/qquickstacklayout.cpp
index 116e162aa..4c1d61140 100644
--- a/src/imports/layouts/qquickstacklayout.cpp
+++ b/src/imports/layouts/qquickstacklayout.cpp
@@ -94,7 +94,7 @@
     \sa ColumnLayout
     \sa GridLayout
     \sa RowLayout
-    \sa StackView
+    \sa {QtQuick.Controls::StackView}{StackView}
 */
 
 QT_BEGIN_NAMESPACE
diff --git a/src/imports/testlib/TestCase.qml b/src/imports/testlib/TestCase.qml
index e7669fd03..6e075d879 100644
--- a/src/imports/testlib/TestCase.qml
+++ b/src/imports/testlib/TestCase.qml
@@ -1631,7 +1631,7 @@ Item {
 
             TestCase {
                 name: "ItemTests"
-                when: area.pressed
+                when: windowShown
                 id: test1
 
                 function test_touch() {
diff --git a/src/particles/qquickcustomaffector.cpp b/src/particles/qquickcustomaffector.cpp
index cadd2992b..5e2133dfa 100644
--- a/src/particles/qquickcustomaffector.cpp
+++ b/src/particles/qquickcustomaffector.cpp
@@ -233,7 +233,7 @@ bool QQuickCustomAffector::affectParticle(QQuickParticleData *d, qreal dt)
     return changed;
 }
 
-void QQuickCustomAffector::affectProperties(const QList<QQuickParticleData*> particles, qreal dt)
+void QQuickCustomAffector::affectProperties(const QList<QQuickParticleData*> &particles, qreal dt)
 {
     foreach (QQuickParticleData* d, particles)
         if ( affectParticle(d, dt) )
diff --git a/src/particles/qquickcustomaffector_p.h b/src/particles/qquickcustomaffector_p.h
index 10db70d71..5b1ea5565 100644
--- a/src/particles/qquickcustomaffector_p.h
+++ b/src/particles/qquickcustomaffector_p.h
@@ -156,7 +156,7 @@ protected:
     bool affectParticle(QQuickParticleData *d, qreal dt) override;
 
 private:
-    void affectProperties(const QList<QQuickParticleData*> particles, qreal dt);
+    void affectProperties(const QList<QQuickParticleData*> &particles, qreal dt);
     QQuickDirection * m_position;
     QQuickDirection * m_velocity;
     QQuickDirection * m_acceleration;
diff --git a/src/particles/qquickimageparticle.cpp b/src/particles/qquickimageparticle.cpp
index bd3865f42..4ce8186c7 100644
--- a/src/particles/qquickimageparticle.cpp
+++ b/src/particles/qquickimageparticle.cpp
@@ -1104,6 +1104,7 @@ void fillUniformArrayFromImage(float* array, const QImage& img, int size)
 QQuickImageParticle::QQuickImageParticle(QQuickItem* parent)
     : QQuickParticlePainter(parent)
     , m_color_variation(0.0)
+    , m_outgoingNode(nullptr)
     , m_material(nullptr)
     , m_alphaVariation(0.0)
     , m_alpha(1.0)
@@ -1149,6 +1150,8 @@ void QQuickImageParticle::sceneGraphInvalidated()
 {
     m_nodes.clear();
     m_material = nullptr;
+    delete m_outgoingNode;
+    m_outgoingNode = nullptr;
 }
 
 void QQuickImageParticle::setImage(const QUrl &image)
@@ -1931,8 +1934,11 @@ QSGNode *QQuickImageParticle::updatePaintNode(QSGNode *node, UpdatePaintNodeData
     }
 
     if (m_pleaseReset){
-        if (node)
-            delete node;
+        // Cannot just destroy the node and then return null (in case image
+        // loading is still in progress). Rather, keep track of the old node
+        // until we have a new one.
+        delete m_outgoingNode;
+        m_outgoingNode = node;
         node = nullptr;
 
         m_lastLevel = perfLevel;
@@ -1946,6 +1952,9 @@ QSGNode *QQuickImageParticle::updatePaintNode(QSGNode *node, UpdatePaintNodeData
 
         m_pleaseReset = false;
         m_startedImageLoading = 0;//Cancel a part-way build (may still have a pending load)
+    } else if (!m_material) {
+        delete node;
+        node = nullptr;
     }
 
     if (m_system && m_system->isRunning() && !m_system->isPaused()){
@@ -1959,6 +1968,11 @@ QSGNode *QQuickImageParticle::updatePaintNode(QSGNode *node, UpdatePaintNodeData
         }
     }
 
+    if (!node) {
+        node = m_outgoingNode;
+        m_outgoingNode = nullptr;
+    }
+
     return node;
 }
 
diff --git a/src/particles/qquickimageparticle_p.h b/src/particles/qquickimageparticle_p.h
index 059cf6701..45eb73b86 100644
--- a/src/particles/qquickimageparticle_p.h
+++ b/src/particles/qquickimageparticle_p.h
@@ -389,6 +389,7 @@ private:
     QColor m_color;
     qreal m_color_variation;
 
+    QSGNode *m_outgoingNode;
     QHash<int, QSGGeometryNode *> m_nodes;
     QHash<int, int> m_idxStarts;//TODO: Proper resizing will lead to needing a spriteEngine per particle - do this after sprite engine gains transparent sharing?
     QList<QPair<int, int> > m_startsIdx;//Same data, optimized for alternate retrieval
diff --git a/src/particles/qquickmaskextruder.cpp b/src/particles/qquickmaskextruder.cpp
index 4c5d9e9d8..2ce365074 100644
--- a/src/particles/qquickmaskextruder.cpp
+++ b/src/particles/qquickmaskextruder.cpp
@@ -68,14 +68,14 @@ QQuickMaskExtruder::QQuickMaskExtruder(QObject *parent) :
 {
 }
 
-void QQuickMaskExtruder::setSource(QUrl arg)
+void QQuickMaskExtruder::setSource(const QUrl &arg)
 {
     if (m_source != arg) {
         m_source = arg;
 
         m_lastHeight = -1;//Trigger reset
         m_lastWidth = -1;
-        emit sourceChanged(arg);
+        emit sourceChanged(m_source);
         startMaskLoading();
     }
 }
diff --git a/src/particles/qquickmaskextruder_p.h b/src/particles/qquickmaskextruder_p.h
index 0fc0331db..bbb61b0d2 100644
--- a/src/particles/qquickmaskextruder_p.h
+++ b/src/particles/qquickmaskextruder_p.h
@@ -73,10 +73,10 @@ public:
 
 Q_SIGNALS:
 
-    void sourceChanged(QUrl arg);
+    void sourceChanged(const QUrl &arg);
 
 public Q_SLOTS:
-    void setSource(QUrl arg);
+    void setSource(const QUrl &arg);
 
 private Q_SLOTS:
     void startMaskLoading();
diff --git a/src/plugins/qmltooling/qmldbg_debugger/qqmlenginedebugservice.cpp b/src/plugins/qmltooling/qmldbg_debugger/qqmlenginedebugservice.cpp
index be83f63bf..029004ffd 100644
--- a/src/plugins/qmltooling/qmldbg_debugger/qqmlenginedebugservice.cpp
+++ b/src/plugins/qmltooling/qmldbg_debugger/qqmlenginedebugservice.cpp
@@ -490,7 +490,7 @@ void QQmlEngineDebugServiceImpl::processMessage(const QByteArray &message)
     QQmlDebugPacket ds(message);
 
     QByteArray type;
-    int queryId;
+    qint32 queryId;
     ds >> type >> queryId;
 
     QQmlDebugPacket rs;
@@ -503,13 +503,13 @@ void QQmlEngineDebugServiceImpl::processMessage(const QByteArray &message)
             QJSEngine *engine = m_engines.at(ii);
 
             QString engineName = engine->objectName();
-            int engineId = QQmlDebugService::idForObject(engine);
+            qint32 engineId = QQmlDebugService::idForObject(engine);
 
             rs << engineName << engineId;
         }
 
     } else if (type == "LIST_OBJECTS") {
-        int engineId = -1;
+        qint32 engineId = -1;
         ds >> engineId;
 
         QQmlEngine *engine =
@@ -532,7 +532,7 @@ void QQmlEngineDebugServiceImpl::processMessage(const QByteArray &message)
         }
 
     } else if (type == "FETCH_OBJECT") {
-        int objectId;
+        qint32 objectId;
         bool recurse;
         bool dumpProperties = true;
 
@@ -550,8 +550,8 @@ void QQmlEngineDebugServiceImpl::processMessage(const QByteArray &message)
 
     } else if (type == "FETCH_OBJECTS_FOR_LOCATION") {
         QString file;
-        int lineNumber;
-        int columnNumber;
+        qint32 lineNumber;
+        qint32 columnNumber;
         bool recurse;
         bool dumpProperties = true;
 
@@ -569,7 +569,7 @@ void QQmlEngineDebugServiceImpl::processMessage(const QByteArray &message)
         }
 
     } else if (type == "WATCH_OBJECT") {
-        int objectId;
+        qint32 objectId;
 
         ds >> objectId;
         bool ok = m_watch->addWatch(queryId, objectId);
@@ -577,7 +577,7 @@ void QQmlEngineDebugServiceImpl::processMessage(const QByteArray &message)
         rs << QByteArray("WATCH_OBJECT_R") << queryId << ok;
 
     } else if (type == "WATCH_PROPERTY") {
-        int objectId;
+        qint32 objectId;
         QByteArray property;
 
         ds >> objectId >> property;
@@ -586,7 +586,7 @@ void QQmlEngineDebugServiceImpl::processMessage(const QByteArray &message)
         rs << QByteArray("WATCH_PROPERTY_R") << queryId << ok;
 
     } else if (type == "WATCH_EXPR_OBJECT") {
-        int debugId;
+        qint32 debugId;
         QString expr;
 
         ds >> debugId >> expr;
@@ -600,11 +600,11 @@ void QQmlEngineDebugServiceImpl::processMessage(const QByteArray &message)
         rs << QByteArray("NO_WATCH_R") << queryId << ok;
 
     } else if (type == "EVAL_EXPRESSION") {
-        int objectId;
+        qint32 objectId;
         QString expr;
 
         ds >> objectId >> expr;
-        int engineId = -1;
+        qint32 engineId = -1;
         if (!ds.atEnd())
             ds >> engineId;
 
@@ -632,12 +632,12 @@ void QQmlEngineDebugServiceImpl::processMessage(const QByteArray &message)
         rs << QByteArray("EVAL_EXPRESSION_R") << queryId << result;
 
     } else if (type == "SET_BINDING") {
-        int objectId;
+        qint32 objectId;
         QString propertyName;
         QVariant expr;
         bool isLiteralValue;
         QString filename;
-        int line;
+        qint32 line;
         ds >> objectId >> propertyName >> expr >> isLiteralValue >>
               filename >> line;
         bool ok = setBinding(objectId, propertyName, expr, isLiteralValue,
@@ -646,7 +646,7 @@ void QQmlEngineDebugServiceImpl::processMessage(const QByteArray &message)
         rs << QByteArray("SET_BINDING_R") << queryId << ok;
 
     } else if (type == "RESET_BINDING") {
-        int objectId;
+        qint32 objectId;
         QString propertyName;
         ds >> objectId >> propertyName;
         bool ok = resetBinding(objectId, propertyName);
@@ -654,7 +654,7 @@ void QQmlEngineDebugServiceImpl::processMessage(const QByteArray &message)
         rs << QByteArray("RESET_BINDING_R") << queryId << ok;
 
     } else if (type == "SET_METHOD_BODY") {
-        int objectId;
+        qint32 objectId;
         QString methodName;
         QString methodBody;
         ds >> objectId >> methodName >> methodBody;
@@ -817,7 +817,8 @@ bool QQmlEngineDebugServiceImpl::setMethodBody(int objectId, const QString &meth
     return true;
 }
 
-void QQmlEngineDebugServiceImpl::propertyChanged(int id, int objectId, const QMetaProperty &property, const QVariant &value)
+void QQmlEngineDebugServiceImpl::propertyChanged(
+        qint32 id, qint32 objectId, const QMetaProperty &property, const QVariant &value)
 {
     QQmlDebugPacket rs;
     rs << QByteArray("UPDATE_WATCH") << id << objectId << QByteArray(property.name()) << valueContents(value);
@@ -848,14 +849,14 @@ void QQmlEngineDebugServiceImpl::objectCreated(QJSEngine *engine, QObject *objec
     if (!m_engines.contains(engine))
         return;
 
-    int engineId = QQmlDebugService::idForObject(engine);
-    int objectId = QQmlDebugService::idForObject(object);
-    int parentId = QQmlDebugService::idForObject(object->parent());
+    qint32 engineId = QQmlDebugService::idForObject(engine);
+    qint32 objectId = QQmlDebugService::idForObject(object);
+    qint32 parentId = QQmlDebugService::idForObject(object->parent());
 
     QQmlDebugPacket rs;
 
     //unique queryId -1
-    rs << QByteArray("OBJECT_CREATED") << -1 << engineId << objectId << parentId;
+    rs << QByteArray("OBJECT_CREATED") << qint32(-1) << engineId << objectId << parentId;
     emit messageToClient(name(), rs.data());
 }
 
diff --git a/src/plugins/qmltooling/qmldbg_debugger/qqmlenginedebugservice.h b/src/plugins/qmltooling/qmldbg_debugger/qqmlenginedebugservice.h
index c0c24058e..741768cd0 100644
--- a/src/plugins/qmltooling/qmldbg_debugger/qqmlenginedebugservice.h
+++ b/src/plugins/qmltooling/qmldbg_debugger/qqmlenginedebugservice.h
@@ -111,7 +111,8 @@ private:
     friend class QQmlDebuggerServiceFactory;
 
     void processMessage(const QByteArray &msg);
-    void propertyChanged(int id, int objectId, const QMetaProperty &property, const QVariant &value);
+    void propertyChanged(qint32 id, qint32 objectId, const QMetaProperty &property,
+                         const QVariant &value);
 
     void prepareDeferredObjects(QObject *);
     void buildObjectList(QDataStream &, QQmlContext *,
diff --git a/src/plugins/qmltooling/qmldbg_server/qqmldebugserver.cpp b/src/plugins/qmltooling/qmldbg_server/qqmldebugserver.cpp
index 2d5282b48..cc663cd6b 100644
--- a/src/plugins/qmltooling/qmldbg_server/qqmldebugserver.cpp
+++ b/src/plugins/qmltooling/qmldbg_server/qqmldebugserver.cpp
@@ -506,7 +506,7 @@ void QQmlDebugServerImpl::receiveMessage()
             in >> m_clientPlugins;
 
             for (DebugServiceConstIt iter = m_plugins.constBegin(), cend = m_plugins.constEnd(); iter != cend; ++iter) {
-                const QString pluginName = iter.key();
+                const QString &pluginName = iter.key();
                 QQmlDebugService::State newState = QQmlDebugService::Unavailable;
                 if (m_clientPlugins.contains(pluginName))
                     newState = QQmlDebugService::Enabled;
diff --git a/src/plugins/scenegraph/openvg/qsgopenvgcontext.cpp b/src/plugins/scenegraph/openvg/qsgopenvgcontext.cpp
index 1736a2098..a5231e15d 100644
--- a/src/plugins/scenegraph/openvg/qsgopenvgcontext.cpp
+++ b/src/plugins/scenegraph/openvg/qsgopenvgcontext.cpp
@@ -76,6 +76,7 @@ void QSGOpenVGRenderContext::initialize(const QSGRenderContext::InitParams *para
 
     m_vgContext = vgparams->context;
     QSGRenderContext::initialize(params);
+    emit initialized();
 }
 
 void QSGOpenVGRenderContext::invalidate()
@@ -84,6 +85,7 @@ void QSGOpenVGRenderContext::invalidate()
     delete m_glyphCacheManager;
     m_glyphCacheManager = nullptr;
     QSGRenderContext::invalidate();
+    emit invalidated();
 }
 
 void QSGOpenVGRenderContext::renderNextFrame(QSGRenderer *renderer, uint fboId)
diff --git a/src/plugins/scenegraph/openvg/qsgopenvginternalrectanglenode.cpp b/src/plugins/scenegraph/openvg/qsgopenvginternalrectanglenode.cpp
index d72868624..2c71c1610 100644
--- a/src/plugins/scenegraph/openvg/qsgopenvginternalrectanglenode.cpp
+++ b/src/plugins/scenegraph/openvg/qsgopenvginternalrectanglenode.cpp
@@ -211,21 +211,14 @@ void QSGOpenVGInternalRectangleNode::render()
     } else {
         vgSeti(VG_MATRIX_MODE, VG_MATRIX_PATH_USER_TO_SURFACE);
         vgLoadIdentity();
-        if (m_radius > 0) {
-            // Fallback to rendering to an image for rounded rects with perspective transforms
-            if (m_offscreenSurface == nullptr || m_offscreenSurface->size() != QSize(std::ceil(m_rect.width()), std::ceil(m_rect.height()))) {
-                delete m_offscreenSurface;
-                m_offscreenSurface = new QOpenVGOffscreenSurface(QSize(std::ceil(m_rect.width()), std::ceil(m_rect.height())));
-            }
-
-            m_offscreenSurface->makeCurrent();
-        } else if (m_offscreenSurface) {
+        // Fallback to rendering to an image for rounded rects with perspective transforms
+        if (m_offscreenSurface == nullptr || m_offscreenSurface->size() != QSize(std::ceil(m_rect.width()), std::ceil(m_rect.height()))) {
             delete m_offscreenSurface;
-            m_offscreenSurface = nullptr;
+            m_offscreenSurface = new QOpenVGOffscreenSurface(QSize(std::ceil(m_rect.width()), std::ceil(m_rect.height())));
         }
+        m_offscreenSurface->makeCurrent();
     }
 
-
     // If path is dirty
     if (m_pathDirty) {
         vgClearPath(m_rectanglePath, VG_PATH_CAPABILITY_APPEND_TO);
@@ -291,7 +284,7 @@ void QSGOpenVGInternalRectangleNode::render()
         vgDrawPath(m_rectanglePath, VG_FILL_PATH);
     }
 
-    if (!transform().isAffine() && m_radius > 0) {
+    if (!transform().isAffine()) {
         m_offscreenSurface->doneCurrent();
         //  Render offscreen surface
         vgSeti(VG_MATRIX_MODE, VG_MATRIX_IMAGE_USER_TO_SURFACE);
diff --git a/src/plugins/scenegraph/openvg/qsgopenvgrenderloop.cpp b/src/plugins/scenegraph/openvg/qsgopenvgrenderloop.cpp
index 69b10fcde..85651ece9 100644
--- a/src/plugins/scenegraph/openvg/qsgopenvgrenderloop.cpp
+++ b/src/plugins/scenegraph/openvg/qsgopenvgrenderloop.cpp
@@ -187,6 +187,7 @@ void QSGOpenVGRenderLoop::renderWindow(QQuickWindow *window)
     data.updatePending = false;
 
     if (!data.grabOnly) {
+        cd->flushFrameSynchronousEvents();
         // Event delivery/processing triggered the window to be deleted or stop rendering.
         if (!m_windows.contains(window))
             return;
diff --git a/src/plugins/scenegraph/openvg/qsgopenvgspritenode.cpp b/src/plugins/scenegraph/openvg/qsgopenvgspritenode.cpp
index fb24df747..1b75d450a 100644
--- a/src/plugins/scenegraph/openvg/qsgopenvgspritenode.cpp
+++ b/src/plugins/scenegraph/openvg/qsgopenvgspritenode.cpp
@@ -52,7 +52,7 @@ QSGOpenVGSpriteNode::QSGOpenVGSpriteNode()
 
 QSGOpenVGSpriteNode::~QSGOpenVGSpriteNode()
 {
-
+    delete m_texture;
 }
 
 void QSGOpenVGSpriteNode::setTexture(QSGTexture *texture)
diff --git a/src/plugins/scenegraph/openvg/qsgopenvgspritenode.h b/src/plugins/scenegraph/openvg/qsgopenvgspritenode.h
index d47b389a0..dba4e663b 100644
--- a/src/plugins/scenegraph/openvg/qsgopenvgspritenode.h
+++ b/src/plugins/scenegraph/openvg/qsgopenvgspritenode.h
@@ -66,7 +66,7 @@ public:
     void render() override;
 
 private:
-    QSGOpenVGTexture *m_texture;
+    QSGOpenVGTexture *m_texture = nullptr;
     float m_time;
     QPoint m_sourceA;
     QPoint m_sourceB;
diff --git a/src/qml/compiler/qqmlirbuilder.cpp b/src/qml/compiler/qqmlirbuilder.cpp
index 171dc641d..665d2633a 100644
--- a/src/qml/compiler/qqmlirbuilder.cpp
+++ b/src/qml/compiler/qqmlirbuilder.cpp
@@ -964,7 +964,7 @@ QStringRef IRBuilder::asStringRef(QQmlJS::AST::Node *node)
     return textRefAt(node->firstSourceLocation(), node->lastSourceLocation());
 }
 
-void IRBuilder::extractVersion(QStringRef string, int *maj, int *min)
+void IRBuilder::extractVersion(const QStringRef &string, int *maj, int *min)
 {
     *maj = -1; *min = -1;
 
diff --git a/src/qml/compiler/qqmlirbuilder_p.h b/src/qml/compiler/qqmlirbuilder_p.h
index c366c8e45..4279f5b76 100644
--- a/src/qml/compiler/qqmlirbuilder_p.h
+++ b/src/qml/compiler/qqmlirbuilder_p.h
@@ -453,7 +453,7 @@ public:
 
     static QString asString(QQmlJS::AST::UiQualifiedId *node);
     QStringRef asStringRef(QQmlJS::AST::Node *node);
-    static void extractVersion(QStringRef string, int *maj, int *min);
+    static void extractVersion(const QStringRef &string, int *maj, int *min);
     QStringRef textRefAt(const QQmlJS::AST::SourceLocation &loc) const
     { return QStringRef(&sourceCode, loc.offset, loc.length); }
     QStringRef textRefAt(const QQmlJS::AST::SourceLocation &first,
diff --git a/src/qml/doc/src/javascript/imports.qdoc b/src/qml/doc/src/javascript/imports.qdoc
index 974f2e154..8e26c4aad 100644
--- a/src/qml/doc/src/javascript/imports.qdoc
+++ b/src/qml/doc/src/javascript/imports.qdoc
@@ -144,14 +144,17 @@ A JavaScript resource may import a QML module in the following fashion:
 .import TypeNamespace MajorVersion.MinorVersion as Qualifier
 \endcode
 
-For example:
+Below you can see an example that also shows how to use the QML types from a
+module imported in javascript:
+
 \code
 .import Qt.test 1.0 as JsQtTest
+
+var importedEnumValue = JsQtTest.MyQmlObject.EnumValue3
 \endcode
 
 In particular, this may be useful in order to access functionality provided
 via a singleton type; see qmlRegisterSingletonType() for more information.
 
 \note The .import syntax doesn't work for scripts used in the \l {WorkerScript}
-
 */
diff --git a/src/qml/doc/src/qmlfunctions.qdoc b/src/qml/doc/src/qmlfunctions.qdoc
index b083012ea..b2d322465 100644
--- a/src/qml/doc/src/qmlfunctions.qdoc
+++ b/src/qml/doc/src/qmlfunctions.qdoc
@@ -628,8 +628,7 @@
 */
 
 /*!
-   \fn int qmlRegisterSingletonInstance(const char *uri, int versionMajor, int
-   versionMinor, const char *typeName, QObject* cppObject)
+   \fn int qmlRegisterSingletonInstance(const char *uri, int versionMajor, int versionMinor, const char *typeName, QObject* cppObject)
    \relates QQmlEngine
    \since 5.14
 
diff --git a/src/qml/doc/src/qmllanguageref/syntax/objectattributes.qdoc b/src/qml/doc/src/qmllanguageref/syntax/objectattributes.qdoc
index c4ecaf367..401e099eb 100644
--- a/src/qml/doc/src/qmllanguageref/syntax/objectattributes.qdoc
+++ b/src/qml/doc/src/qmllanguageref/syntax/objectattributes.qdoc
@@ -464,22 +464,24 @@ Unlike an ordinary property, an alias has the following restrictions:
     must be provided when the alias is first declared.
 \li It cannot refer to \l {Attached Properties and Attached Signal Handlers}
     {attached properties}.
-\li It cannot refer to grouped properties; the following code will not work:
+\li It cannot refer to properties inside a hierarchy with depth 3 or greater. The
+    following code will not work:
     \code
-    property alias color: rectangle.border.color
+    property alias color: myItem.myRect.border.color
 
-    Rectangle {
-        id: rectangle
+    Item {
+        id: myItem
+        property Rectangle myRect
     }
     \endcode
 
-    However, aliases to \l {QML Basic Types}{value type} properties do work:
+    However, aliases to properties that are up to two levels deep will work.
+
     \code
-    property alias rectX: object.rectProperty.x
+    property alias color: rectangle.border.color
 
-    Item {
-        id: object
-        property rect rectProperty
+    Rectangle {
+        id: rectangle
     }
     \endcode
 \endlist
diff --git a/src/qml/jsruntime/qv4dateobject.cpp b/src/qml/jsruntime/qv4dateobject.cpp
index 5616b1450..cc89947ce 100644
--- a/src/qml/jsruntime/qv4dateobject.cpp
+++ b/src/qml/jsruntime/qv4dateobject.cpp
@@ -294,13 +294,28 @@ static double MakeDay(double year, double month, double day)
     if (month < 0)
         month += 12.0;
 
-    double d = DayFromYear(year);
-    bool leap = InLeapYear(d*msPerDay);
+    /* Quoting the spec:
 
-    d += DayFromMonth(month, leap);
-    d += day - 1;
+       Find a value t such that YearFromTime(t) is ym and MonthFromTime(t) is mn
+       and DateFromTime(t) is 1; but if this is not possible (because some
+       argument is out of range), return NaN.
+    */
+    double first = DayFromYear(year);
+    /* Beware floating-point glitches: don't test the first millisecond of a
+     * year, month or day when we could test a moment firmly in the interior of
+     * the interval. A rounding glitch might give the first millisecond to the
+     * preceding interval.
+     */
+    bool leap = InLeapYear((first + 60) * msPerDay);
 
-    return d;
+    first += DayFromMonth(month, leap);
+    const double t = first * msPerDay + msPerDay / 2; // Noon on the first of the month
+    Q_ASSERT(Day(t) == first);
+    if (YearFromTime(t) != year || MonthFromTime(t) != month || DateFromTime(t) != 1) {
+        qWarning("Apparently out-of-range date %.0f-%02.0f-%02.0f", year, month, day);
+        return qt_qnan();
+    }
+    return first + day - 1;
 }
 
 static inline double MakeDate(double day, double time)
@@ -601,8 +616,7 @@ static inline double ParseString(const QString &s, double localTZA)
             QStringLiteral("d MMMM, yyyy hh:mm:ss"),
         };
 
-        for (uint i = 0; i < sizeof(formats) / sizeof(formats[0]); ++i) {
-            const QString &format(formats[i]);
+        for (const QString &format : formats) {
             dt = format.indexOf(QLatin1String("hh:mm")) < 0
                 ? QDateTime(QDate::fromString(s, format),
                             QTime(0, 0, 0), Qt::UTC)
diff --git a/src/qml/jsruntime/qv4qobjectwrapper.cpp b/src/qml/jsruntime/qv4qobjectwrapper.cpp
index c36da3815..9d0b65cc0 100644
--- a/src/qml/jsruntime/qv4qobjectwrapper.cpp
+++ b/src/qml/jsruntime/qv4qobjectwrapper.cpp
@@ -1622,7 +1622,7 @@ static QV4::ReturnedValue CallOverloaded(const QQmlObjectOrGadget &object, const
 
         int methodMatchScore = 0;
         for (int ii = 0; ii < methodArgumentCount; ++ii) {
-            methodMatchScore += MatchScore((v = Value::fromStaticValue(callArgs->args[ii])),
+            methodMatchScore += MatchScore((v = QV4::Value::fromStaticValue(callArgs->args[ii])),
                                            methodArgTypes[ii]);
         }
 
@@ -2268,7 +2268,7 @@ ReturnedValue QMetaObjectWrapper::callOverloadedConstructor(QV4::ExecutionEngine
 
         int methodMatchScore = 0;
         for (int ii = 0; ii < methodArgumentCount; ++ii) {
-            methodMatchScore += MatchScore((v = Value::fromStaticValue(callArgs->args[ii])),
+            methodMatchScore += MatchScore((v = QV4::Value::fromStaticValue(callArgs->args[ii])),
                                            methodArgTypes[ii]);
         }
 
diff --git a/src/qml/jsruntime/qv4scopedvalue_p.h b/src/qml/jsruntime/qv4scopedvalue_p.h
index e4aceef3e..12a6381e6 100644
--- a/src/qml/jsruntime/qv4scopedvalue_p.h
+++ b/src/qml/jsruntime/qv4scopedvalue_p.h
@@ -70,7 +70,7 @@ struct ScopedValue;
 
 #define CHECK_EXCEPTION() \
     do { \
-        if (scope.hasException()) { \
+        if (scope.hasException() || scope.engine->isInterrupted.loadAcquire()) { \
             return QV4::Encode::undefined(); \
         } \
     } while (false)
diff --git a/src/qml/jsruntime/qv4stackframe_p.h b/src/qml/jsruntime/qv4stackframe_p.h
index bf689a74b..616fa9a5a 100644
--- a/src/qml/jsruntime/qv4stackframe_p.h
+++ b/src/qml/jsruntime/qv4stackframe_p.h
@@ -117,7 +117,7 @@ struct Q_QML_EXPORT CppStackFrame {
     void setupJSFrame(Value *stackSpace, const Value &function, const Heap::ExecutionContext *scope,
                       const Value &thisObject, const Value &newTarget = Value::undefinedValue()) {
         setupJSFrame(stackSpace, function, scope, thisObject, newTarget,
-                     v4Function->nFormals, v4Function->compiledFunction->nRegisters);
+                     v4Function->compiledFunction->nFormals, v4Function->compiledFunction->nRegisters);
     }
     void setupJSFrame(Value *stackSpace, const Value &function, const Heap::ExecutionContext *scope,
                       const Value &thisObject, const Value &newTarget, uint nFormals, uint nRegisters)
diff --git a/src/qml/jsruntime/qv4vme_moth.cpp b/src/qml/jsruntime/qv4vme_moth.cpp
index 27d518f5c..ad5a6ebc8 100644
--- a/src/qml/jsruntime/qv4vme_moth.cpp
+++ b/src/qml/jsruntime/qv4vme_moth.cpp
@@ -364,7 +364,7 @@ static inline Heap::CallContext *getScope(QV4::Value *stack, int level)
 
 static inline const QV4::Value &constant(Function *function, int index)
 {
-    return function->compilationUnit->constants[index].asValue<Value>();
+    return function->compilationUnit->constants[index].asValue<QV4::Value>();
 }
 
 static bool compareEqualInt(QV4::Value &accumulator, QV4::Value lhs, int rhs)
diff --git a/src/qml/qml/ftw/qflagpointer_p.h b/src/qml/qml/ftw/qflagpointer_p.h
index 71b41cd30..a10e57aec 100644
--- a/src/qml/qml/ftw/qflagpointer_p.h
+++ b/src/qml/qml/ftw/qflagpointer_p.h
@@ -55,6 +55,17 @@
 
 QT_BEGIN_NAMESPACE
 
+namespace QtPrivate {
+template <typename T> struct QFlagPointerAlignment
+{
+    enum : size_t { Value = Q_ALIGNOF(T) };
+};
+template <> struct QFlagPointerAlignment<void>
+{
+    enum : size_t { Value = ~size_t(0) };
+};
+}
+
 template<typename T>
 class QFlagPointer {
 public:
@@ -133,6 +144,7 @@ template<typename T>
 QFlagPointer<T>::QFlagPointer(T *v)
 : ptr_value(quintptr(v))
 {
+    Q_STATIC_ASSERT_X(Q_ALIGNOF(T) >= 4, "Type T does not have sufficient alignment");
     Q_ASSERT((ptr_value & FlagsMask) == 0);
 }
 
@@ -247,6 +259,8 @@ template<typename T, typename T2>
 QBiPointer<T, T2>::QBiPointer(T *v)
 : ptr_value(quintptr(v))
 {
+    Q_STATIC_ASSERT_X(QtPrivate::QFlagPointerAlignment<T>::Value >= 4,
+                      "Type T does not have sufficient alignment");
     Q_ASSERT((quintptr(v) & FlagsMask) == 0);
 }
 
@@ -254,6 +268,8 @@ template<typename T, typename T2>
 QBiPointer<T, T2>::QBiPointer(T2 *v)
 : ptr_value(quintptr(v) | Flag2Bit)
 {
+    Q_STATIC_ASSERT_X(QtPrivate::QFlagPointerAlignment<T2>::Value >= 4,
+                      "Type T2 does not have sufficient alignment");
     Q_ASSERT((quintptr(v) & FlagsMask) == 0);
 }
 
diff --git a/src/qml/qml/ftw/qqmlthread.cpp b/src/qml/qml/ftw/qqmlthread.cpp
index e961ed3d0..7d2ad354d 100644
--- a/src/qml/qml/ftw/qqmlthread.cpp
+++ b/src/qml/qml/ftw/qqmlthread.cpp
@@ -131,6 +131,9 @@ QQmlThreadPrivate::QQmlThreadPrivate(QQmlThread *q)
   m_mainThreadWaiting(false), mainSync(nullptr), m_mainObject(this)
 {
     setObjectName(QStringLiteral("QQmlThread"));
+    // This size is aligned with the recursion depth limits in the parser/codegen. In case of
+    // absurd content we want to hit the recursion checks instead of running out of stack.
+    setStackSize(8 * 1024 * 1024);
 }
 
 bool QQmlThreadPrivate::event(QEvent *e)
diff --git a/src/qml/qml/qqml.cpp b/src/qml/qml/qqml.cpp
index 8a50b51b5..5b16a3c9e 100644
--- a/src/qml/qml/qqml.cpp
+++ b/src/qml/qml/qqml.cpp
@@ -79,6 +79,13 @@ int qmlTypeId(const char *uri, int versionMajor, int versionMinor, const char *q
 // From qqmlprivate.h
 QObject *QQmlPrivate::RegisterSingletonFunctor::operator()(QQmlEngine *qeng, QJSEngine *)
 {
+    if (!m_object) {
+        QQmlError error;
+        error.setDescription(QLatin1String("The registered singleton has already been deleted. Ensure that it outlives the engine."));
+        QQmlEnginePrivate::get(qeng)->warning(qeng, error);
+        return nullptr;
+    }
+
     if (qeng->thread() != m_object->thread()) {
         QQmlError error;
         error.setDescription(QLatin1String("Registered object must live in the same thread as the engine it was registered with"));
diff --git a/src/qml/qml/qqmlbinding.cpp b/src/qml/qml/qqmlbinding.cpp
index 3a437eab8..52572be2b 100644
--- a/src/qml/qml/qqmlbinding.cpp
+++ b/src/qml/qml/qqmlbinding.cpp
@@ -298,8 +298,9 @@ protected:
             case QMetaType::Int:
                 if (result.isInteger())
                     return doStore<int>(result.integerValue(), pd, flags);
-                else if (result.isNumber())
-                    return doStore<int>(result.doubleValue(), pd, flags);
+                else if (result.isNumber()) {
+                    return doStore<int>(QV4::StaticValue::toInteger(result.doubleValue()), pd, flags);
+                }
                 break;
             case QMetaType::Double:
                 if (result.isNumber())
diff --git a/src/qml/qml/qqmlcontext.cpp b/src/qml/qml/qqmlcontext.cpp
index 14892bd6a..f75a076bc 100644
--- a/src/qml/qml/qqmlcontext.cpp
+++ b/src/qml/qml/qqmlcontext.cpp
@@ -358,7 +358,7 @@ void QQmlContext::setContextProperties(const QVector<PropertyPair> &properties)
     data->expressions = nullptr;
     data->childContexts = nullptr;
 
-    for (auto property : properties)
+    for (const auto &property : properties)
         setContextProperty(property.name, property.value);
 
     data->expressions = expressions;
@@ -532,6 +532,9 @@ QObject *QQmlContextPrivate::context_at(QQmlListProperty<QObject> *prop, int ind
 
 void QQmlContextPrivate::dropDestroyedQObject(const QString &name, QObject *destroyed)
 {
+    if (!data->isValid())
+        return;
+
     const int idx = data->propertyNames().value(name);
     Q_ASSERT(idx >= 0);
     if (qvariant_cast<QObject *>(propertyValues[idx]) != destroyed)
diff --git a/src/qml/qml/qqmldatablob.cpp b/src/qml/qml/qqmldatablob.cpp
index 2183721d3..750fc6de5 100644
--- a/src/qml/qml/qqmldatablob.cpp
+++ b/src/qml/qml/qqmldatablob.cpp
@@ -351,7 +351,7 @@ void QQmlDataBlob::addDependency(QQmlDataBlob *blob)
         status() == Error || status() == Complete || m_isDone)
         return;
 
-    for (auto existingDep: qAsConst(m_waitingFor))
+    for (const auto &existingDep: qAsConst(m_waitingFor))
         if (existingDep.data() == blob)
             return;
 
diff --git a/src/qml/qml/qqmldirdata.cpp b/src/qml/qml/qqmldirdata.cpp
index 7652cec32..de74dfdf9 100644
--- a/src/qml/qml/qqmldirdata.cpp
+++ b/src/qml/qml/qqmldirdata.cpp
@@ -61,7 +61,7 @@ QQmlTypeLoader::Blob::PendingImportPtr QQmlQmldirData::import(QQmlTypeLoader::Bl
 
 void QQmlQmldirData::setImport(QQmlTypeLoader::Blob *blob, QQmlTypeLoader::Blob::PendingImportPtr import)
 {
-    m_imports[blob] = import;
+    m_imports[blob] = std::move(import);
 }
 
 int QQmlQmldirData::priority(QQmlTypeLoader::Blob *blob) const
diff --git a/src/qml/qml/qqmlimport.cpp b/src/qml/qml/qqmlimport.cpp
index 5feea9daa..3bf8d807a 100644
--- a/src/qml/qml/qqmlimport.cpp
+++ b/src/qml/qml/qqmlimport.cpp
@@ -780,12 +780,12 @@ bool QQmlImportInstance::resolveType(QQmlTypeLoader *typeLoader, const QHashedSt
             typeStr + dotqml_string, // Type -> Type.qml
             typeStr + dotuidotqml_string // Type -> Type.ui.qml
         };
-        for (uint i = 0; i < sizeof(urlsToTry) / sizeof(urlsToTry[0]); ++i) {
-            exists = typeLoader->fileExists(localDirectoryPath, urlsToTry[i]);
+        for (const QString &urlToTry : urlsToTry) {
+            exists = typeLoader->fileExists(localDirectoryPath, urlToTry);
             if (exists) {
 #if defined(Q_OS_MACOS) || defined(Q_OS_WIN)
                 // don't let function.qml confuse the use of "new Function(...)" for example.
-                if (!QQml_isFileCaseCorrect(localDirectoryPath + urlsToTry[i])) {
+                if (!QQml_isFileCaseCorrect(localDirectoryPath + urlToTry)) {
                     exists = false;
                     if (errors) {
                         QQmlError caseError;
@@ -797,7 +797,7 @@ bool QQmlImportInstance::resolveType(QQmlTypeLoader *typeLoader, const QHashedSt
 #else
                 Q_UNUSED(errors);
 #endif
-                qmlUrl = url + urlsToTry[i];
+                qmlUrl = url + urlToTry;
                 break;
             }
         }
@@ -1812,7 +1812,8 @@ QString QQmlImportDatabase::resolvePlugin(QQmlTypeLoader *typeLoader,
         if (qmldirPath.size() > 25 && qmldirPath.at(0) == QLatin1Char(':') && qmldirPath.at(1) == QLatin1Char('/') &&
            qmldirPath.startsWith(QStringLiteral(":/android_rcc_bundle/qml/"), Qt::CaseInsensitive)) {
             QString pluginName = qmldirPath.mid(21) + Slash + baseName;
-            auto bundledPath = resolvedPath + QLatin1String("lib") + pluginName.replace(QLatin1Char('/'), QLatin1Char('_'));
+            pluginName.replace(QLatin1Char('/'), QLatin1Char('_'));
+            QString bundledPath = resolvedPath + QLatin1String("lib") + pluginName;
             for (const QString &suffix : suffixes) {
                 const QString absolutePath = typeLoader->absoluteFilePath(bundledPath + suffix);
                 if (!absolutePath.isEmpty())
diff --git a/src/qml/qml/qqmlmetatypedata.cpp b/src/qml/qml/qqmlmetatypedata.cpp
index 41a7778da..775bc8bdb 100644
--- a/src/qml/qml/qqmlmetatypedata.cpp
+++ b/src/qml/qml/qqmlmetatypedata.cpp
@@ -150,7 +150,7 @@ QQmlPropertyCache *QQmlMetaTypeData::propertyCache(const QQmlType &type, int min
     bool hasCopied = false;
 
     for (int ii = 0; ii < types.count(); ++ii) {
-        QQmlType currentType = types.at(ii);
+        const QQmlType &currentType = types.at(ii);
         if (!currentType.isValid())
             continue;
 
diff --git a/src/qml/qml/qqmlobjectcreator.cpp b/src/qml/qml/qqmlobjectcreator.cpp
index f89608cd5..a4270628e 100644
--- a/src/qml/qml/qqmlobjectcreator.cpp
+++ b/src/qml/qml/qqmlobjectcreator.cpp
@@ -445,6 +445,8 @@ void QQmlObjectCreator::setPropertyValue(const QQmlPropertyData *property, const
                 QV4::ScopedString s(scope, v4->newString(stringValue));
                 _vmeMetaObject->setVMEProperty(property->coreIndex(), s);
             } else {
+                // ### Qt 6: Doing the conversion here where we don't know the eventual target type is rather strange
+                // and caused for instance QTBUG-78943
                 QVariant value = QQmlStringConverters::variantFromString(stringValue);
                 property->writeProperty(_qobject, &value, propertyWriteFlags);
             }
diff --git a/src/qml/qml/qqmlprivate.h b/src/qml/qml/qqmlprivate.h
index e6dd5e0b1..6d7a2569b 100644
--- a/src/qml/qml/qqmlprivate.h
+++ b/src/qml/qml/qqmlprivate.h
@@ -58,6 +58,7 @@
 #include <QtCore/qglobal.h>
 #include <QtCore/qvariant.h>
 #include <QtCore/qurl.h>
+#include <QtCore/qpointer.h>
 
 QT_BEGIN_NAMESPACE
 
@@ -326,7 +327,7 @@ namespace QQmlPrivate
     {
         QObject *operator()(QQmlEngine *, QJSEngine *);
 
-        QObject *m_object;
+        QPointer<QObject> m_object;
         bool alreadyCalled = false;
     };
 }
diff --git a/src/qml/qml/qqmlproperty.cpp b/src/qml/qml/qqmlproperty.cpp
index 5f57e0eca..b6baa86bd 100644
--- a/src/qml/qml/qqmlproperty.cpp
+++ b/src/qml/qml/qqmlproperty.cpp
@@ -1373,8 +1373,9 @@ bool QQmlPropertyPrivate::write(QObject *object,
             }
         }
         if (!ok) {
-            // the only other option is that they are assigning a single value
+            // the only other options are that they are assigning a single value
             // to a sequence type property (eg, an int to a QList<int> property).
+            // or that we encountered an interface type
             // Note that we've already handled single-value assignment to QList<QUrl> properties.
             if (variantType == QVariant::Int && propertyType == qMetaTypeId<QList<int> >()) {
                 QList<int> list;
@@ -1405,6 +1406,15 @@ bool QQmlPropertyPrivate::write(QObject *object,
             }
         }
 
+        if (!ok && QQmlMetaType::isInterface(propertyType)) {
+            auto valueAsQObject = qvariant_cast<QObject *>(value);
+            if (valueAsQObject && valueAsQObject->qt_metacast(QQmlMetaType::interfaceIId(propertyType))) {
+                // this case can occur when object has an interface type
+                // and the variant contains a type implementing the interface
+                return property.writeProperty(object, const_cast<void *>(value.constData()), flags);
+            }
+        }
+
         if (ok) {
             return property.writeProperty(object, const_cast<void *>(v.constData()), flags);
         } else {
diff --git a/src/qml/qml/qqmlpropertycachecreator_p.h b/src/qml/qml/qqmlpropertycachecreator_p.h
index 94bf3cbdc..39778aa32 100644
--- a/src/qml/qml/qqmlpropertycachecreator_p.h
+++ b/src/qml/qml/qqmlpropertycachecreator_p.h
@@ -585,13 +585,13 @@ public:
 
     QQmlPropertyCacheAliasCreator(QQmlPropertyCacheVector *propertyCaches, const ObjectContainer *objectContainer);
 
-    void appendAliasPropertiesToMetaObjects();
+    void appendAliasPropertiesToMetaObjects(QQmlEnginePrivate *enginePriv);
 
-    QQmlJS::DiagnosticMessage appendAliasesToPropertyCache(const CompiledObject &component, int objectIndex);
+    QQmlJS::DiagnosticMessage appendAliasesToPropertyCache(const CompiledObject &component, int objectIndex, QQmlEnginePrivate *enginePriv);
 
 private:
-    void appendAliasPropertiesInMetaObjectsWithinComponent(const CompiledObject &component, int firstObjectIndex);
-    QQmlJS::DiagnosticMessage propertyDataForAlias(const CompiledObject &component, const QV4::CompiledData::Alias &alias, int *type, int *rev, QQmlPropertyData::Flags *propertyFlags);
+    void appendAliasPropertiesInMetaObjectsWithinComponent(const CompiledObject &component, int firstObjectIndex, QQmlEnginePrivate *enginePriv);
+    QQmlJS::DiagnosticMessage propertyDataForAlias(const CompiledObject &component, const QV4::CompiledData::Alias &alias, int *type, int *rev, QQmlPropertyData::Flags *propertyFlags, QQmlEnginePrivate *enginePriv);
 
     void collectObjectsWithAliasesRecursively(int objectIndex, QVector<int> *objectsWithAliases) const;
 
@@ -610,7 +610,7 @@ inline QQmlPropertyCacheAliasCreator<ObjectContainer>::QQmlPropertyCacheAliasCre
 }
 
 template <typename ObjectContainer>
-inline void QQmlPropertyCacheAliasCreator<ObjectContainer>::appendAliasPropertiesToMetaObjects()
+inline void QQmlPropertyCacheAliasCreator<ObjectContainer>::appendAliasPropertiesToMetaObjects(QQmlEnginePrivate *enginePriv)
 {
     // skip the root object (index 0) as that one does not have a first object index originating
     // from a binding.
@@ -620,15 +620,15 @@ inline void QQmlPropertyCacheAliasCreator<ObjectContainer>::appendAliasPropertie
             continue;
 
         const auto rootBinding = component.bindingsBegin();
-        appendAliasPropertiesInMetaObjectsWithinComponent(component, rootBinding->value.objectIndex);
+        appendAliasPropertiesInMetaObjectsWithinComponent(component, rootBinding->value.objectIndex, enginePriv);
     }
 
     const int rootObjectIndex = 0;
-    appendAliasPropertiesInMetaObjectsWithinComponent(*objectContainer->objectAt(rootObjectIndex), rootObjectIndex);
+    appendAliasPropertiesInMetaObjectsWithinComponent(*objectContainer->objectAt(rootObjectIndex), rootObjectIndex, enginePriv);
 }
 
 template <typename ObjectContainer>
-inline void QQmlPropertyCacheAliasCreator<ObjectContainer>::appendAliasPropertiesInMetaObjectsWithinComponent(const CompiledObject &component, int firstObjectIndex)
+inline void QQmlPropertyCacheAliasCreator<ObjectContainer>::appendAliasPropertiesInMetaObjectsWithinComponent(const CompiledObject &component, int firstObjectIndex, QQmlEnginePrivate *enginePriv)
 {
     QVector<int> objectsWithAliases;
     collectObjectsWithAliasesRecursively(firstObjectIndex, &objectsWithAliases);
@@ -668,7 +668,7 @@ inline void QQmlPropertyCacheAliasCreator<ObjectContainer>::appendAliasPropertie
             const CompiledObject &object = *objectContainer->objectAt(objectIndex);
 
             if (allAliasTargetsExist(object)) {
-                appendAliasesToPropertyCache(component, objectIndex);
+                appendAliasesToPropertyCache(component, objectIndex, enginePriv);
             } else {
                 pendingObjects.append(objectIndex);
             }
@@ -702,9 +702,8 @@ inline void QQmlPropertyCacheAliasCreator<ObjectContainer>::collectObjectsWithAl
 }
 
 template <typename ObjectContainer>
-inline QQmlJS::DiagnosticMessage QQmlPropertyCacheAliasCreator<ObjectContainer>::propertyDataForAlias(
-        const CompiledObject &component, const QV4::CompiledData::Alias &alias, int *type, int *minorVersion,
-        QQmlPropertyData::Flags *propertyFlags)
+inline QQmlJS::DiagnosticMessage QQmlPropertyCacheAliasCreator<ObjectContainer>::propertyDataForAlias(const CompiledObject &component, const QV4::CompiledData::Alias &alias, int *type, int *minorVersion,
+        QQmlPropertyData::Flags *propertyFlags, QQmlEnginePrivate *enginePriv)
 {
     *type = 0;
     bool writable = false;
@@ -736,7 +735,7 @@ inline QQmlJS::DiagnosticMessage QQmlPropertyCacheAliasCreator<ObjectContainer>:
             lastAlias = targetAlias;
         } while (lastAlias->aliasToLocalAlias);
 
-        return propertyDataForAlias(component, *lastAlias, type, minorVersion, propertyFlags);
+        return propertyDataForAlias(component, *lastAlias, type, minorVersion, propertyFlags, enginePriv);
     }
 
     const int targetObjectIndex = objectForId(component, alias.targetObjectId);
@@ -768,29 +767,46 @@ inline QQmlJS::DiagnosticMessage QQmlPropertyCacheAliasCreator<ObjectContainer>:
 
         QQmlPropertyCache *targetCache = propertyCaches->at(targetObjectIndex);
         Q_ASSERT(targetCache);
+
         QQmlPropertyData *targetProperty = targetCache->property(coreIndex);
         Q_ASSERT(targetProperty);
 
-        *type = targetProperty->propType();
+        // for deep aliases, valueTypeIndex is always set
+        if (!QQmlValueTypeFactory::isValueType(targetProperty->propType()) && valueTypeIndex != -1) {
+            // deep alias property
+            *type = targetProperty->propType();
+            targetCache = enginePriv->propertyCacheForType(*type);
+            Q_ASSERT(targetCache);
+            targetProperty = targetCache->property(valueTypeIndex);
 
-        writable = targetProperty->isWritable();
-        resettable = targetProperty->isResettable();
 
-        if (valueTypeIndex != -1) {
-            const QMetaObject *valueTypeMetaObject = QQmlValueTypeFactory::metaObjectForMetaType(*type);
-            if (valueTypeMetaObject->property(valueTypeIndex).isEnumType())
-                *type = QVariant::Int;
-            else
-                *type = valueTypeMetaObject->property(valueTypeIndex).userType();
+            *type = targetProperty->propType();
+            writable = targetProperty->isWritable();
+            resettable = targetProperty->isResettable();
+
         } else {
-            if (targetProperty->isEnum()) {
-                *type = QVariant::Int;
+            // value type or primitive type or enum
+            *type = targetProperty->propType();
+
+            writable = targetProperty->isWritable();
+            resettable = targetProperty->isResettable();
+
+            if (valueTypeIndex != -1) {
+                const QMetaObject *valueTypeMetaObject = QQmlValueTypeFactory::metaObjectForMetaType(*type);
+                if (valueTypeMetaObject->property(valueTypeIndex).isEnumType())
+                    *type = QVariant::Int;
+                else
+                    *type = valueTypeMetaObject->property(valueTypeIndex).userType();
             } else {
-                // Copy type flags
-                propertyFlags->copyPropertyTypeFlags(targetProperty->flags());
+                if (targetProperty->isEnum()) {
+                    *type = QVariant::Int;
+                } else {
+                    // Copy type flags
+                    propertyFlags->copyPropertyTypeFlags(targetProperty->flags());
 
-                if (targetProperty->isVarProperty())
-                    propertyFlags->type = QQmlPropertyData::Flags::QVariantType;
+                    if (targetProperty->isVarProperty())
+                        propertyFlags->type = QQmlPropertyData::Flags::QVariantType;
+                }
             }
         }
     }
@@ -802,7 +818,7 @@ inline QQmlJS::DiagnosticMessage QQmlPropertyCacheAliasCreator<ObjectContainer>:
 
 template <typename ObjectContainer>
 inline QQmlJS::DiagnosticMessage QQmlPropertyCacheAliasCreator<ObjectContainer>::appendAliasesToPropertyCache(
-        const CompiledObject &component, int objectIndex)
+        const CompiledObject &component, int objectIndex, QQmlEnginePrivate *enginePriv)
 {
     const CompiledObject &object = *objectContainer->objectAt(objectIndex);
     if (!object.aliasCount())
@@ -823,7 +839,7 @@ inline QQmlJS::DiagnosticMessage QQmlPropertyCacheAliasCreator<ObjectContainer>:
         int type = 0;
         int minorVersion = 0;
         QQmlPropertyData::Flags propertyFlags;
-        QQmlJS::DiagnosticMessage error = propertyDataForAlias(component, *alias, &type, &minorVersion, &propertyFlags);
+        QQmlJS::DiagnosticMessage error = propertyDataForAlias(component, *alias, &type, &minorVersion, &propertyFlags, enginePriv);
         if (error.isValid())
             return error;
 
diff --git a/src/qml/qml/qqmlpropertyvalidator.cpp b/src/qml/qml/qqmlpropertyvalidator.cpp
index 6959b0510..ef85d6e4d 100644
--- a/src/qml/qml/qqmlpropertyvalidator.cpp
+++ b/src/qml/qml/qqmlpropertyvalidator.cpp
@@ -728,12 +728,12 @@ QQmlJS::DiagnosticMessage QQmlPropertyValidator::validateObjectBinding(QQmlPrope
         return noError;
     } else if (isPrimitiveType(propType)) {
         auto typeName = QMetaType::typeName(propType);
-        return qQmlCompileError(binding->location, tr("Can not assign value of type \"%1\" to property \"%2\", expecting \"%3\"")
+        return qQmlCompileError(binding->location, tr("Cannot assign value of type \"%1\" to property \"%2\", expecting \"%3\"")
                                                       .arg(rhsType())
                                                       .arg(propertyName)
                                                       .arg(typeName));
     } else if (QQmlValueTypeFactory::isValueType(propType)) {
-        return qQmlCompileError(binding->location, tr("Can not assign value of type \"%1\" to property \"%2\", expecting an object")
+        return qQmlCompileError(binding->location, tr("Cannot assign value of type \"%1\" to property \"%2\", expecting an object")
                                                       .arg(rhsType()).arg(propertyName));
     } else if (propType == qMetaTypeId<QQmlScriptString>()) {
         return qQmlCompileError(binding->valueLocation, tr("Invalid property assignment: script expected"));
diff --git a/src/qml/qml/qqmltype.cpp b/src/qml/qml/qqmltype.cpp
index 3615749da..874bcd4bc 100644
--- a/src/qml/qml/qqmltype.cpp
+++ b/src/qml/qml/qqmltype.cpp
@@ -91,6 +91,8 @@ QQmlTypePrivate::QQmlTypePrivate(QQmlType::RegistrationType type)
 QQmlTypePrivate::~QQmlTypePrivate()
 {
     qDeleteAll(scopedEnums);
+    for (const auto &metaObject : metaObjects)
+        free(metaObject.metaObject);
     switch (regType) {
     case QQmlType::CppType:
         delete extraData.cd->customParser;
@@ -393,7 +395,7 @@ void QQmlTypePrivate::createEnumConflictReport(const QMetaObject *metaObject, co
 
     qWarning().noquote() << QLatin1String("Possible conflicting items:");
     // find items with conflicting key
-    for (const auto i : enumInfoList) {
+    for (const auto &i : qAsConst(enumInfoList)) {
         if (i.enumKey == conflictingKey)
         qWarning().noquote().nospace() << "    " << i.metaObjectName << "." << i.enumName << "." << i.enumKey << " from scope "
                                            << i.metaEnumScope << " injected by " << i.path.join(QLatin1String("->"));
diff --git a/src/qml/qml/qqmltypecompiler.cpp b/src/qml/qml/qqmltypecompiler.cpp
index bbeaf7be9..9ff0e3fb9 100644
--- a/src/qml/qml/qqmltypecompiler.cpp
+++ b/src/qml/qml/qqmltypecompiler.cpp
@@ -1016,7 +1016,7 @@ bool QQmlComponentAndAliasResolver::resolveAliases(int componentIndex)
             }
 
             if (result == AllAliasesResolved) {
-                QQmlJS::DiagnosticMessage error = aliasCacheCreator.appendAliasesToPropertyCache(*qmlObjects->at(componentIndex), objectIndex);
+                QQmlJS::DiagnosticMessage error = aliasCacheCreator.appendAliasesToPropertyCache(*qmlObjects->at(componentIndex), objectIndex, enginePrivate);
                 if (error.isValid()) {
                     recordError(error);
                     return false;
@@ -1143,23 +1143,42 @@ QQmlComponentAndAliasResolver::resolveAliasesInObject(int objectIndex,
             if (!subProperty.isEmpty()) {
                 const QMetaObject *valueTypeMetaObject = QQmlValueTypeFactory::metaObjectForMetaType(targetProperty->propType());
                 if (!valueTypeMetaObject) {
-                    *error = qQmlCompileError(
-                            alias->referenceLocation,
-                            tr("Invalid alias target location: %1").arg(subProperty.toString()));
-                    break;
-                }
+                    // could be a deep alias
+                    bool isDeepAlias = subProperty.at(0).isLower();
+                    if (isDeepAlias) {
+                        isDeepAlias = false;
+                        for (auto it = targetObject->bindingsBegin(); it != targetObject->bindingsEnd(); ++it) {
+                            auto binding = *it;
+                            if (compiler->stringAt(binding.propertyNameIndex) == property) {
+                                resolver = QQmlPropertyResolver(propertyCaches.at(binding.value.objectIndex));
+                                QQmlPropertyData *actualProperty = resolver.property(subProperty.toString());
+                                if (actualProperty) {
+                                    propIdx = QQmlPropertyIndex(propIdx.coreIndex(), actualProperty->coreIndex());
+                                    isDeepAlias = true;
+                                }
+                            }
+                        }
+                    }
+                    if (!isDeepAlias) {
+                        *error = qQmlCompileError(
+                                alias->referenceLocation,
+                                tr("Invalid alias target location: %1").arg(subProperty.toString()));
+                        break;
+                    }
+                } else {
 
-                int valueTypeIndex =
-                        valueTypeMetaObject->indexOfProperty(subProperty.toString().toUtf8().constData());
-                if (valueTypeIndex == -1) {
-                    *error = qQmlCompileError(
-                            alias->referenceLocation,
-                            tr("Invalid alias target location: %1").arg(subProperty.toString()));
-                    break;
-                }
-                Q_ASSERT(valueTypeIndex <= 0x0000FFFF);
+                    int valueTypeIndex =
+                            valueTypeMetaObject->indexOfProperty(subProperty.toString().toUtf8().constData());
+                    if (valueTypeIndex == -1) {
+                        *error = qQmlCompileError(
+                                alias->referenceLocation,
+                                tr("Invalid alias target location: %1").arg(subProperty.toString()));
+                        break;
+                    }
+                    Q_ASSERT(valueTypeIndex <= 0x0000FFFF);
 
-                propIdx = QQmlPropertyIndex(propIdx.coreIndex(), valueTypeIndex);
+                    propIdx = QQmlPropertyIndex(propIdx.coreIndex(), valueTypeIndex);
+                }
             } else {
                 if (targetProperty->isQObject())
                     alias->flags |= QV4::CompiledData::Alias::AliasPointsToPointerObject;
diff --git a/src/qml/qml/qqmltypedata.cpp b/src/qml/qml/qqmltypedata.cpp
index 99fe06968..cfdcf6aad 100644
--- a/src/qml/qml/qqmltypedata.cpp
+++ b/src/qml/qml/qqmltypedata.cpp
@@ -209,7 +209,7 @@ void QQmlTypeData::createTypeAndPropertyCaches(
 
     QQmlPropertyCacheAliasCreator<QV4::ExecutableCompilationUnit> aliasCreator(
             &m_compiledData->propertyCaches, m_compiledData.data());
-    aliasCreator.appendAliasPropertiesToMetaObjects();
+    aliasCreator.appendAliasPropertiesToMetaObjects(engine);
 
     pendingGroupPropertyBindings.resolveMissingPropertyCaches(engine, &m_compiledData->propertyCaches);
 }
diff --git a/src/qml/qml/qqmltypeloader.cpp b/src/qml/qml/qqmltypeloader.cpp
index 42e7d2c4b..62007effd 100644
--- a/src/qml/qml/qqmltypeloader.cpp
+++ b/src/qml/qml/qqmltypeloader.cpp
@@ -491,7 +491,7 @@ bool QQmlTypeLoader::Blob::fetchQmldir(const QUrl &url, PendingImportPtr import,
 {
     QQmlRefPointer<QQmlQmldirData> data = typeLoader()->getQmldir(url);
 
-    data->setImport(this, import);
+    data->setImport(this, std::move(import));
     data->setPriority(this, priority);
 
     if (data->status() == Error) {
diff --git a/src/qml/qml/qqmltypeloaderqmldircontent.cpp b/src/qml/qml/qqmltypeloaderqmldircontent.cpp
index 238af9b71..8e983db75 100644
--- a/src/qml/qml/qqmltypeloaderqmldircontent.cpp
+++ b/src/qml/qml/qqmltypeloaderqmldircontent.cpp
@@ -55,7 +55,8 @@ QList<QQmlError> QQmlTypeLoaderQmldirContent::errors(const QString &uri) const
 {
     QList<QQmlError> errors;
     const QUrl url(uri);
-    for (const auto parseError : m_parser.errors(uri)) {
+    const auto parseErrors = m_parser.errors(uri);
+    for (const auto &parseError : parseErrors) {
         QQmlError error;
         error.setUrl(url);
         error.setLine(parseError.line);
diff --git a/src/qml/qml/qqmlvmemetaobject.cpp b/src/qml/qml/qqmlvmemetaobject.cpp
index b9d8fed24..abdc686ec 100644
--- a/src/qml/qml/qqmlvmemetaobject.cpp
+++ b/src/qml/qml/qqmlvmemetaobject.cpp
@@ -164,8 +164,19 @@ void QQmlVMEMetaObjectEndpoint::tryConnect()
             QQmlData *targetDData = QQmlData::get(target, /*create*/false);
             if (!targetDData)
                 return;
-            int coreIndex = QQmlPropertyIndex::fromEncoded(aliasData->encodedMetaPropertyIndex).coreIndex();
+            QQmlPropertyIndex encodedIndex = QQmlPropertyIndex::fromEncoded(aliasData->encodedMetaPropertyIndex);
+            int coreIndex = encodedIndex.coreIndex();
+            int valueTypeIndex = encodedIndex.valueTypeIndex();
             const QQmlPropertyData *pd = targetDData->propertyCache->property(coreIndex);
+            if (pd && valueTypeIndex != -1 && !QQmlValueTypeFactory::valueType(pd->propType())) {
+                // deep alias
+                QQmlEnginePrivate *enginePriv = QQmlEnginePrivate::get(metaObject->compilationUnit->engine->qmlEngine());
+                auto const *newPropertyCache = enginePriv->propertyCacheForType(pd->propType());
+                void *argv[1] = { &target };
+                QMetaObject::metacall(target, QMetaObject::ReadProperty, coreIndex, argv);
+                Q_ASSERT(newPropertyCache);
+                pd = newPropertyCache->property(valueTypeIndex);
+            }
             if (!pd)
                 return;
 
@@ -858,17 +869,23 @@ int QQmlVMEMetaObject::metaCall(QObject *o, QMetaObject::Call c, int _id, void *
                     if (!targetDData->propertyCache)
                         return -1;
                     const QQmlPropertyData *pd = targetDData->propertyCache->property(coreIndex);
-                    // Value type property
+                    // Value type property or deep alias
                     QQmlValueType *valueType = QQmlValueTypeFactory::valueType(pd->propType());
-                    Q_ASSERT(valueType);
+                    if (valueType) {
 
-                    valueType->read(target, coreIndex);
-                    int rv = QMetaObject::metacall(valueType, c, valueTypePropertyIndex, a);
+                        valueType->read(target, coreIndex);
+                        int rv = QMetaObject::metacall(valueType, c, valueTypePropertyIndex, a);
 
-                    if (c == QMetaObject::WriteProperty)
-                        valueType->write(target, coreIndex, nullptr);
+                        if (c == QMetaObject::WriteProperty)
+                            valueType->write(target, coreIndex, nullptr);
 
-                    return rv;
+                        return rv;
+                    } else {
+                        // deep alias
+                        void *argv[1] = { &target };
+                        QMetaObject::metacall(target, QMetaObject::ReadProperty, coreIndex, argv);
+                        return QMetaObject::metacall(target, c, valueTypePropertyIndex, a);
+                    }
 
                 } else {
                     return QMetaObject::metacall(target, c, coreIndex, a);
diff --git a/src/qml/types/qqmlbind.cpp b/src/qml/types/qqmlbind.cpp
index 861243987..921d60caa 100644
--- a/src/qml/types/qqmlbind.cpp
+++ b/src/qml/types/qqmlbind.cpp
@@ -54,11 +54,14 @@
 #include <QtCore/qfile.h>
 #include <QtCore/qdebug.h>
 #include <QtCore/qtimer.h>
+#include <QtCore/qloggingcategory.h>
 
 #include <private/qobject_p.h>
 
 QT_BEGIN_NAMESPACE
 
+Q_DECLARE_LOGGING_CATEGORY(lcBindingRemoval)
+
 class QQmlBindPrivate : public QObjectPrivate
 {
 public:
@@ -72,13 +75,14 @@ public:
         , restoreBinding(true)
         , restoreValue(false)
         , restoreModeExplicit(false)
+        , writingProperty(false)
     {}
     ~QQmlBindPrivate() { }
 
     QQmlNullableValue<bool> when;
     QPointer<QObject> obj;
     QString propName;
-    QQmlNullableValue<QVariant> value;
+    QQmlNullableValue<QJSValue> value;
     QQmlProperty prop;
     QQmlAbstractBinding::Ptr prevBind;
     QV4::PersistentValue v4Value;
@@ -90,6 +94,7 @@ public:
     bool restoreBinding:1;
     bool restoreValue:1;
     bool restoreModeExplicit:1;
+    bool writingProperty: 1;
 
     void validate(QObject *binding) const;
     void clearPrev();
@@ -193,6 +198,13 @@ QQmlBind::~QQmlBind()
 
     When the binding becomes inactive again, any direct bindings that were previously
     set on the property will be restored.
+
+    \note By default, a previously set literal value is not restored when the Binding becomes
+    inactive. Rather, the last value set by the now inactive Binding is retained. You can customize
+    the restoration behavior for literal values as well as bindings using the \l restoreMode
+    property. The default will change in Qt 6.0.
+
+    \sa restoreMode
 */
 bool QQmlBind::when() const
 {
@@ -235,7 +247,7 @@ void QQmlBind::setObject(QObject *obj)
     }
     d->obj = obj;
     if (d->componentComplete) {
-        d->prop = QQmlProperty(d->obj, d->propName, qmlContext(this));
+        setTarget(QQmlProperty(d->obj, d->propName, qmlContext(this)));
         d->validate(this);
     }
     eval();
@@ -281,7 +293,7 @@ void QQmlBind::setProperty(const QString &p)
     }
     d->propName = p;
     if (d->componentComplete) {
-        d->prop = QQmlProperty(d->obj, d->propName, qmlContext(this));
+        setTarget(QQmlProperty(d->obj, d->propName, qmlContext(this)));
         d->validate(this);
     }
     eval();
@@ -293,13 +305,13 @@ void QQmlBind::setProperty(const QString &p)
     The value to be set on the target object and property.  This can be a
     constant (which isn't very useful), or a bound expression.
 */
-QVariant QQmlBind::value() const
+QJSValue QQmlBind::value() const
 {
     Q_D(const QQmlBind);
     return d->value.value;
 }
 
-void QQmlBind::setValue(const QVariant &v)
+void QQmlBind::setValue(const QJSValue &v)
 {
     Q_D(QQmlBind);
     d->value = v;
@@ -359,7 +371,8 @@ void QQmlBind::setDelayed(bool delayed)
     \li Binding.RestoreBindingOrValue The original value is always restored.
     \endlist
 
-    The default value is Binding.RestoreBinding.
+    \warning The default value is Binding.RestoreBinding. This will change in
+    Qt 6.0 to Binding.RestoreBindingOrValue.
 
     If you rely on any specific behavior regarding the restoration of plain
     values when bindings get disabled you should migrate to explicitly set the
@@ -382,10 +395,10 @@ QQmlBind::RestorationMode QQmlBind::restoreMode() const
 void QQmlBind::setRestoreMode(RestorationMode newMode)
 {
     Q_D(QQmlBind);
+    d->restoreModeExplicit = true;
     if (newMode != restoreMode()) {
         d->restoreValue = (newMode & RestoreValue);
         d->restoreBinding = (newMode & RestoreBinding);
-        d->restoreModeExplicit = true;
         emit restoreModeChanged();
     }
 }
@@ -393,6 +406,19 @@ void QQmlBind::setRestoreMode(RestorationMode newMode)
 void QQmlBind::setTarget(const QQmlProperty &p)
 {
     Q_D(QQmlBind);
+
+    if (Q_UNLIKELY(lcBindingRemoval().isInfoEnabled())) {
+        if (QObject *oldObject = d->prop.object()) {
+            QMetaProperty prop = oldObject->metaObject()->property(d->prop.index());
+            if (prop.hasNotifySignal()) {
+                QByteArray signal('2' + prop.notifySignal().methodSignature());
+                QObject::disconnect(oldObject, signal.constData(),
+                                    this, SLOT(targetValueChanged()));
+            }
+        }
+        p.connectNotifySignal(this, SLOT(targetValueChanged()));
+    }
+
     d->prop = p;
 }
 
@@ -407,7 +433,7 @@ void QQmlBind::componentComplete()
     Q_D(QQmlBind);
     d->componentComplete = true;
     if (!d->prop.isValid()) {
-        d->prop = QQmlProperty(d->obj, d->propName, qmlContext(this));
+        setTarget(QQmlProperty(d->obj, d->propName, qmlContext(this)));
         d->validate(this);
     }
     eval();
@@ -456,11 +482,23 @@ void QQmlBind::eval()
                     Q_ASSERT(vmemo);
                     vmemo->setVMEProperty(propPriv->core.coreIndex(), *d->v4Value.valueRef());
                     d->clearPrev();
+                } else if (!d->restoreModeExplicit) {
+                    qmlWarning(this)
+                            << "Not restoring previous value because restoreMode has not been set."
+                            << "This behavior is deprecated."
+                            << "In Qt < 6.0 the default is Binding.RestoreBinding."
+                            << "In Qt >= 6.0 the default is Binding.RestoreBindingOrValue.";
                 }
             } else if (d->prevIsVariant) {
                 if (d->restoreValue) {
                     d->prop.write(d->prevValue);
                     d->clearPrev();
+                } else if (!d->restoreModeExplicit) {
+                    qmlWarning(this)
+                            << "Not restoring previous value because restoreMode has not been set."
+                            << "This behavior is deprecated."
+                            << "In Qt < 6.0 the default is Binding.RestoreBinding."
+                            << "In Qt >= 6.0 the default is Binding.RestoreBindingOrValue.";
                 }
             }
             return;
@@ -489,7 +527,34 @@ void QQmlBind::eval()
         QQmlPropertyPrivate::removeBinding(d->prop);
     }
 
-    d->prop.write(d->value.value);
+    d->writingProperty = true;
+    d->prop.write(d->value.value.toVariant());
+    d->writingProperty = false;
+}
+
+void QQmlBind::targetValueChanged()
+{
+    Q_D(QQmlBind);
+    if (d->writingProperty)
+        return;
+
+    if (d->when.isValid() && !d->when)
+        return;
+
+    QUrl url;
+    quint16 line = 0;
+
+    const QQmlData *ddata = QQmlData::get(this, false);
+    if (ddata && ddata->outerContext) {
+        url = ddata->outerContext->url();
+        line = ddata->lineNumber;
+    }
+
+    qCInfo(lcBindingRemoval,
+           "The target property of the Binding element created at %s:%d was changed from "
+           "elsewhere. This does not overwrite the binding. The target property will still be "
+           "updated when the value of the Binding element changes.",
+           qPrintable(url.toString()), line);
 }
 
 QT_END_NAMESPACE
diff --git a/src/qml/types/qqmlbind_p.h b/src/qml/types/qqmlbind_p.h
index 22007a3d2..7bf4fc4df 100644
--- a/src/qml/types/qqmlbind_p.h
+++ b/src/qml/types/qqmlbind_p.h
@@ -75,7 +75,7 @@ private:
     Q_INTERFACES(QQmlPropertyValueSource)
     Q_PROPERTY(QObject *target READ object WRITE setObject)
     Q_PROPERTY(QString property READ property WRITE setProperty)
-    Q_PROPERTY(QVariant value READ value WRITE setValue)
+    Q_PROPERTY(QJSValue value READ value WRITE setValue)
     Q_PROPERTY(bool when READ when WRITE setWhen)
     Q_PROPERTY(bool delayed READ delayed WRITE setDelayed REVISION 8)
     Q_PROPERTY(RestorationMode restoreMode READ restoreMode WRITE setRestoreMode
@@ -95,8 +95,8 @@ public:
     QString property() const;
     void setProperty(const QString &);
 
-    QVariant value() const;
-    void setValue(const QVariant &);
+    QJSValue value() const;
+    void setValue(const QJSValue &);
 
     bool delayed() const;
     void setDelayed(bool);
@@ -115,6 +115,9 @@ protected:
 private:
     void prepareEval();
     void eval();
+
+private Q_SLOTS:
+    void targetValueChanged();
 };
 
 QT_END_NAMESPACE
diff --git a/src/qmldebug/qqmlenginedebugclient.cpp b/src/qmldebug/qqmlenginedebugclient.cpp
index 50f8deb08..0ca3f573d 100644
--- a/src/qmldebug/qqmlenginedebugclient.cpp
+++ b/src/qmldebug/qqmlenginedebugclient.cpp
@@ -33,14 +33,14 @@ QT_BEGIN_NAMESPACE
 
 struct QQmlObjectData {
     QUrl url;
-    int lineNumber = -1;
-    int columnNumber = -1;
+    qint32 lineNumber = -1;
+    qint32 columnNumber = -1;
     QString idString;
     QString objectName;
     QString objectType;
-    int objectId = -1;
-    int contextId = -1;
-    int parentId = -1;
+    qint32 objectId = -1;
+    qint32 contextId = -1;
+    qint32 parentId = -1;
 };
 
 QPacket &operator>>(QPacket &ds, QQmlObjectData &data)
@@ -63,10 +63,10 @@ struct QQmlObjectProperty {
 
 QPacket &operator>>(QPacket &ds, QQmlObjectProperty &data)
 {
-    int type;
+    qint32 type;
     ds >> type >> data.name >> data.value >> data.valueTypeName
        >> data.binding >> data.hasNotifySignal;
-    data.type = (QQmlObjectProperty::Type)type;
+    data.type = QQmlObjectProperty::Type(type);
     return ds;
 }
 
@@ -81,10 +81,10 @@ QQmlEngineDebugClientPrivate::QQmlEngineDebugClientPrivate(QQmlDebugConnection *
 }
 
 
-quint32 QQmlEngineDebugClient::addWatch(
+qint32 QQmlEngineDebugClient::addWatch(
         const QQmlEngineDebugPropertyReference &property, bool *success)
 {
-    quint32 id = -1;
+    qint32 id = -1;
     *success = false;
     if (state() == QQmlDebugClient::Enabled) {
         id = getId();
@@ -97,19 +97,19 @@ quint32 QQmlEngineDebugClient::addWatch(
     return id;
 }
 
-quint32 QQmlEngineDebugClient::addWatch(
+qint32 QQmlEngineDebugClient::addWatch(
         const QQmlEngineDebugContextReference &, const QString &, bool *success)
 {
     *success = false;
     qWarning("QQmlEngineDebugClient::addWatch(): Not implemented");
-    return 0;
+    return -1;
 }
 
-quint32 QQmlEngineDebugClient::addWatch(
+qint32 QQmlEngineDebugClient::addWatch(
         const QQmlEngineDebugObjectReference &object, const QString &expr,
         bool *success)
 {
-    quint32 id = -1;
+    qint32 id = -1;
     *success = false;
     if (state() == QQmlDebugClient::Enabled) {
         id = getId();
@@ -121,10 +121,10 @@ quint32 QQmlEngineDebugClient::addWatch(
     return id;
 }
 
-quint32 QQmlEngineDebugClient::addWatch(
+qint32 QQmlEngineDebugClient::addWatch(
         const QQmlEngineDebugObjectReference &object, bool *success)
 {
-    quint32 id = -1;
+    qint32 id = -1;
     *success = false;
     if (state() == QQmlDebugClient::Enabled) {
         id = getId();
@@ -136,15 +136,15 @@ quint32 QQmlEngineDebugClient::addWatch(
     return id;
 }
 
-quint32 QQmlEngineDebugClient::addWatch(
+qint32 QQmlEngineDebugClient::addWatch(
         const QQmlEngineDebugFileReference &,  bool *success)
 {
     *success = false;
     qWarning("QQmlEngineDebugClient::addWatch(): Not implemented");
-    return 0;
+    return -1;
 }
 
-void QQmlEngineDebugClient::removeWatch(quint32 id, bool *success)
+void QQmlEngineDebugClient::removeWatch(qint32 id, bool *success)
 {
     *success = false;
     if (state() == QQmlDebugClient::Enabled) {
@@ -155,11 +155,11 @@ void QQmlEngineDebugClient::removeWatch(quint32 id, bool *success)
     }
 }
 
-quint32 QQmlEngineDebugClient::queryAvailableEngines(bool *success)
+qint32 QQmlEngineDebugClient::queryAvailableEngines(bool *success)
 {
     Q_D(QQmlEngineDebugClient);
     d->engines.clear();
-    quint32 id = -1;
+    qint32 id = -1;
     *success = false;
     if (state() == QQmlDebugClient::Enabled) {
         id = getId();
@@ -171,12 +171,12 @@ quint32 QQmlEngineDebugClient::queryAvailableEngines(bool *success)
     return id;
 }
 
-quint32 QQmlEngineDebugClient::queryRootContexts(
+qint32 QQmlEngineDebugClient::queryRootContexts(
         const QQmlEngineDebugEngineReference &engine, bool *success)
 {
     Q_D(QQmlEngineDebugClient);
     d->rootContext = QQmlEngineDebugContextReference();
-    quint32 id = -1;
+    qint32 id = -1;
     *success = false;
     if (state() == QQmlDebugClient::Enabled && engine.debugId != -1) {
         id = getId();
@@ -188,12 +188,12 @@ quint32 QQmlEngineDebugClient::queryRootContexts(
     return id;
 }
 
-quint32 QQmlEngineDebugClient::queryObject(
+qint32 QQmlEngineDebugClient::queryObject(
         const QQmlEngineDebugObjectReference &object, bool *success)
 {
     Q_D(QQmlEngineDebugClient);
     d->object = QQmlEngineDebugObjectReference();
-    quint32 id = -1;
+    qint32 id = -1;
     *success = false;
     if (state() == QQmlDebugClient::Enabled && object.debugId != -1) {
         id = getId();
@@ -205,12 +205,12 @@ quint32 QQmlEngineDebugClient::queryObject(
     return id;
 }
 
-quint32 QQmlEngineDebugClient::queryObjectsForLocation(
-        const QString &file, int lineNumber, int columnNumber, bool *success)
+qint32 QQmlEngineDebugClient::queryObjectsForLocation(
+        const QString &file, qint32 lineNumber, qint32 columnNumber, bool *success)
 {
     Q_D(QQmlEngineDebugClient);
     d->objects.clear();
-    quint32 id = -1;
+    qint32 id = -1;
     *success = false;
     if (state() == QQmlDebugClient::Enabled) {
         id = getId();
@@ -223,12 +223,12 @@ quint32 QQmlEngineDebugClient::queryObjectsForLocation(
     return id;
 }
 
-quint32 QQmlEngineDebugClient::queryObjectRecursive(
+qint32 QQmlEngineDebugClient::queryObjectRecursive(
         const QQmlEngineDebugObjectReference &object, bool *success)
 {
     Q_D(QQmlEngineDebugClient);
     d->object = QQmlEngineDebugObjectReference();
-    quint32 id = -1;
+    qint32 id = -1;
     *success = false;
     if (state() == QQmlDebugClient::Enabled && object.debugId != -1) {
         id = getId();
@@ -240,12 +240,12 @@ quint32 QQmlEngineDebugClient::queryObjectRecursive(
     return id;
 }
 
-quint32 QQmlEngineDebugClient::queryObjectsForLocationRecursive(const QString &file,
-        int lineNumber, int columnNumber, bool *success)
+qint32 QQmlEngineDebugClient::queryObjectsForLocationRecursive(const QString &file,
+        qint32 lineNumber, qint32 columnNumber, bool *success)
 {
     Q_D(QQmlEngineDebugClient);
     d->objects.clear();
-    quint32 id = -1;
+    qint32 id = -1;
     *success = false;
     if (state() == QQmlDebugClient::Enabled) {
         id = getId();
@@ -258,12 +258,12 @@ quint32 QQmlEngineDebugClient::queryObjectsForLocationRecursive(const QString &f
     return id;
 }
 
-quint32 QQmlEngineDebugClient::queryExpressionResult(
-        int objectDebugId, const QString &expr, bool *success)
+qint32 QQmlEngineDebugClient::queryExpressionResult(
+        qint32 objectDebugId, const QString &expr, bool *success)
 {
     Q_D(QQmlEngineDebugClient);
     d->exprResult = QVariant();
-    quint32 id = -1;
+    qint32 id = -1;
     *success = false;
     if (state() == QQmlDebugClient::Enabled) {
         id = getId();
@@ -276,12 +276,12 @@ quint32 QQmlEngineDebugClient::queryExpressionResult(
     return id;
 }
 
-quint32 QQmlEngineDebugClient::queryExpressionResultBC(
-        int objectDebugId, const QString &expr, bool *success)
+qint32 QQmlEngineDebugClient::queryExpressionResultBC(
+        qint32 objectDebugId, const QString &expr, bool *success)
 {
     Q_D(QQmlEngineDebugClient);
     d->exprResult = QVariant();
-    quint32 id = -1;
+    qint32 id = -1;
     *success = false;
     if (state() == QQmlDebugClient::Enabled) {
         id = getId();
@@ -293,15 +293,15 @@ quint32 QQmlEngineDebugClient::queryExpressionResultBC(
     return id;
 }
 
-quint32 QQmlEngineDebugClient::setBindingForObject(
-        int objectDebugId,
+qint32 QQmlEngineDebugClient::setBindingForObject(
+        qint32 objectDebugId,
         const QString &propertyName,
         const QVariant &bindingExpression,
         bool isLiteralValue,
-        const QString &source, int line,
+        const QString &source, qint32 line,
         bool *success)
 {
-    quint32 id = -1;
+    qint32 id = -1;
     *success = false;
     if (state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
         id = getId();
@@ -314,12 +314,12 @@ quint32 QQmlEngineDebugClient::setBindingForObject(
     return id;
 }
 
-quint32 QQmlEngineDebugClient::resetBindingForObject(
-        int objectDebugId,
+qint32 QQmlEngineDebugClient::resetBindingForObject(
+        qint32 objectDebugId,
         const QString &propertyName,
         bool *success)
 {
-    quint32 id = -1;
+    qint32 id = -1;
     *success = false;
     if (state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
         id = getId();
@@ -331,11 +331,11 @@ quint32 QQmlEngineDebugClient::resetBindingForObject(
     return id;
 }
 
-quint32 QQmlEngineDebugClient::setMethodBody(
-        int objectDebugId, const QString &methodName,
+qint32 QQmlEngineDebugClient::setMethodBody(
+        qint32 objectDebugId, const QString &methodName,
         const QString &methodBody, bool *success)
 {
-    quint32 id = -1;
+    qint32 id = -1;
     *success = false;
     if (state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
         id = getId();
@@ -366,19 +366,19 @@ void QQmlEngineDebugClient::decode(QPacket &ds,
     if (simple)
         return;
 
-    int childCount;
+    qint32 childCount;
     bool recur;
     ds >> childCount >> recur;
 
-    for (int ii = 0; ii < childCount; ++ii) {
+    for (qint32 ii = 0; ii < childCount; ++ii) {
         o.children.append(QQmlEngineDebugObjectReference());
         decode(ds, o.children.last(), !recur);
     }
 
-    int propCount;
+    qint32 propCount;
     ds >> propCount;
 
-    for (int ii = 0; ii < propCount; ++ii) {
+    for (qint32 ii = 0; ii < propCount; ++ii) {
         QQmlObjectProperty data;
         ds >> data;
         QQmlEngineDebugPropertyReference prop;
@@ -414,9 +414,9 @@ void QQmlEngineDebugClient::decode(QPacket &ds,
                                    QList<QQmlEngineDebugObjectReference> &o,
                                    bool simple)
 {
-    int count;
+    qint32 count;
     ds >> count;
-    for (int i = 0; i < count; i++) {
+    for (qint32 i = 0; i < count; i++) {
         QQmlEngineDebugObjectReference obj;
         decode(ds, obj, simple);
         o << obj;
@@ -464,18 +464,18 @@ void QQmlEngineDebugClient::decode(QPacket &ds,
 {
     ds >> c.name >> c.debugId;
 
-    int contextCount;
+    qint32 contextCount;
     ds >> contextCount;
 
-    for (int ii = 0; ii < contextCount; ++ii) {
+    for (qint32 ii = 0; ii < contextCount; ++ii) {
         c.contexts.append(QQmlEngineDebugContextReference());
         decode(ds, c.contexts.last());
     }
 
-    int objectCount;
+    qint32 objectCount;
     ds >> objectCount;
 
-    for (int ii = 0; ii < objectCount; ++ii) {
+    for (qint32 ii = 0; ii < objectCount; ++ii) {
         QQmlEngineDebugObjectReference obj;
         decode(ds, obj, true);
 
@@ -490,18 +490,18 @@ void QQmlEngineDebugClient::messageReceived(const QByteArray &data)
     d->valid = false;
     QPacket ds(connection()->currentDataStreamVersion(), data);
 
-    int queryId;
+    qint32 queryId;
     QByteArray type;
     ds >> type >> queryId;
 
     //qDebug() << "QQmlEngineDebugPrivate::message()" << type;
 
     if (type == "LIST_ENGINES_R") {
-        int count;
+        qint32 count;
         ds >> count;
 
         d->engines.clear();
-        for (int ii = 0; ii < count; ++ii) {
+        for (qint32 ii = 0; ii < count; ++ii) {
             QQmlEngineDebugEngineReference eng;
             ds >> eng.name;
             ds >> eng.debugId;
@@ -532,7 +532,7 @@ void QQmlEngineDebugClient::messageReceived(const QByteArray &data)
         ds >> d->valid;
 
     } else if (type == "UPDATE_WATCH") {
-        int debugId;
+        qint32 debugId;
         QByteArray name;
         QVariant value;
         ds >> debugId >> name >> value;
@@ -540,7 +540,9 @@ void QQmlEngineDebugClient::messageReceived(const QByteArray &data)
         return;
 
     } else if (type == "OBJECT_CREATED") {
-        int engineId, objectId, parentId;
+        qint32 engineId;
+        qint32 objectId;
+        qint32 parentId;
         ds >> engineId >> objectId >> parentId;
         emit newObject(objectId);
         return;
@@ -557,7 +559,7 @@ void QQmlEngineDebugClient::messageReceived(const QByteArray &data)
 }
 
 
-quint32 QQmlEngineDebugClient::getId()
+qint32 QQmlEngineDebugClient::getId()
 {
     Q_D(QQmlEngineDebugClient);
     return d->nextId++;
diff --git a/src/qmldebug/qqmlenginedebugclient_p.h b/src/qmldebug/qqmlenginedebugclient_p.h
index 4a9cc3a02..0a01f2eac 100644
--- a/src/qmldebug/qqmlenginedebugclient_p.h
+++ b/src/qmldebug/qqmlenginedebugclient_p.h
@@ -50,7 +50,7 @@ QT_BEGIN_NAMESPACE
 
 struct QQmlEngineDebugPropertyReference
 {
-    int objectDebugId = -1;
+    qint32 objectDebugId = -1;
     QString name;
     QVariant value;
     QString valueTypeName;
@@ -61,25 +61,25 @@ struct QQmlEngineDebugPropertyReference
 struct QQmlEngineDebugFileReference
 {
     QUrl url;
-    int lineNumber = -1;
-    int columnNumber = -1;
+    qint32 lineNumber = -1;
+    qint32 columnNumber = -1;
 };
 
 struct QQmlEngineDebugObjectReference
 {
-    int debugId = -1;
+    qint32 debugId = -1;
     QString className;
     QString idString;
     QString name;
     QQmlEngineDebugFileReference source;
-    int contextDebugId = -1;
+    qint32 contextDebugId = -1;
     QList<QQmlEngineDebugPropertyReference> properties;
     QList<QQmlEngineDebugObjectReference> children;
 };
 
 struct QQmlEngineDebugContextReference
 {
-    int debugId = -1;
+    qint32 debugId = -1;
     QString name;
     QList<QQmlEngineDebugObjectReference> objects;
     QList<QQmlEngineDebugContextReference> contexts;
@@ -87,7 +87,7 @@ struct QQmlEngineDebugContextReference
 
 struct QQmlEngineDebugEngineReference
 {
-    int debugId = -1;
+    qint32 debugId = -1;
     QString name;
 };
 
@@ -100,46 +100,46 @@ class QQmlEngineDebugClient : public QQmlDebugClient
 public:
     explicit QQmlEngineDebugClient(QQmlDebugConnection *conn);
 
-    quint32 addWatch(const QQmlEngineDebugPropertyReference &,
-                     bool *success);
-    quint32 addWatch(const QQmlEngineDebugContextReference &, const QString &,
-                     bool *success);
-    quint32 addWatch(const QQmlEngineDebugObjectReference &, const QString &,
-                     bool *success);
-    quint32 addWatch(const QQmlEngineDebugObjectReference &,
-                     bool *success);
-    quint32 addWatch(const QQmlEngineDebugFileReference &,
+    qint32 addWatch(const QQmlEngineDebugPropertyReference &,
+                    bool *success);
+    qint32 addWatch(const QQmlEngineDebugContextReference &, const QString &,
+                    bool *success);
+    qint32 addWatch(const QQmlEngineDebugObjectReference &, const QString &,
+                    bool *success);
+    qint32 addWatch(const QQmlEngineDebugObjectReference &,
+                    bool *success);
+    qint32 addWatch(const QQmlEngineDebugFileReference &,
                      bool *success);
 
-    void removeWatch(quint32 watch, bool *success);
-
-    quint32 queryAvailableEngines(bool *success);
-    quint32 queryRootContexts(const QQmlEngineDebugEngineReference &,
-                              bool *success);
-    quint32 queryObject(const QQmlEngineDebugObjectReference &,
-                        bool *success);
-    quint32 queryObjectsForLocation(const QString &file,
-            int lineNumber, int columnNumber, bool *success);
-    quint32 queryObjectRecursive(const QQmlEngineDebugObjectReference &,
+    void removeWatch(qint32 watch, bool *success);
+
+    qint32 queryAvailableEngines(bool *success);
+    qint32 queryRootContexts(const QQmlEngineDebugEngineReference &,
+                             bool *success);
+    qint32 queryObject(const QQmlEngineDebugObjectReference &,
+                       bool *success);
+    qint32 queryObjectsForLocation(const QString &file,
+           qint32 lineNumber, qint32 columnNumber, bool *success);
+    qint32 queryObjectRecursive(const QQmlEngineDebugObjectReference &,
+                                bool *success);
+    qint32 queryObjectsForLocationRecursive(const QString &file,
+           qint32 lineNumber, qint32 columnNumber, bool *success);
+    qint32 queryExpressionResult(qint32 objectDebugId,
+                                 const QString &expr,
+                                 bool *success);
+    qint32 queryExpressionResultBC(qint32 objectDebugId,
+                                 const QString &expr,
                                  bool *success);
-    quint32 queryObjectsForLocationRecursive(const QString &file,
-            int lineNumber, int columnNumber, bool *success);
-    quint32 queryExpressionResult(int objectDebugId,
-                                  const QString &expr,
-                                  bool *success);
-    quint32 queryExpressionResultBC(int objectDebugId,
-                                  const QString &expr,
-                                  bool *success);
-    quint32 setBindingForObject(int objectDebugId, const QString &propertyName,
-                                const QVariant &bindingExpression,
-                                bool isLiteralValue,
-                                const QString &source, int line, bool *success);
-    quint32 resetBindingForObject(int objectDebugId,
-                                  const QString &propertyName, bool *success);
-    quint32 setMethodBody(int objectDebugId, const QString &methodName,
-                          const QString &methodBody, bool *success);
-
-    quint32 getId();
+    qint32 setBindingForObject(qint32 objectDebugId, const QString &propertyName,
+                               const QVariant &bindingExpression,
+                               bool isLiteralValue,
+                               const QString &source, qint32 line, bool *success);
+    qint32 resetBindingForObject(qint32 objectDebugId,
+                                 const QString &propertyName, bool *success);
+    qint32 setMethodBody(qint32 objectDebugId, const QString &methodName,
+                         const QString &methodBody, bool *success);
+
+    qint32 getId();
 
     void decode(QPacket &ds, QQmlEngineDebugContextReference &);
     void decode(QPacket &ds, QQmlEngineDebugObjectReference &, bool simple);
@@ -153,7 +153,7 @@ public:
     bool valid() const;
 
 signals:
-    void newObject(int objectId);
+    void newObject(qint32 objectId);
     void valueChanged(QByteArray,QVariant);
     void result();
 
diff --git a/src/qmldebug/qqmlenginedebugclient_p_p.h b/src/qmldebug/qqmlenginedebugclient_p_p.h
index 7c992ad3a..b73da15e9 100644
--- a/src/qmldebug/qqmlenginedebugclient_p_p.h
+++ b/src/qmldebug/qqmlenginedebugclient_p_p.h
@@ -62,7 +62,7 @@ class QQmlEngineDebugClientPrivate : public QQmlDebugClientPrivate
 public:
     QQmlEngineDebugClientPrivate(QQmlDebugConnection *connection);
 
-    quint32 nextId = 0;
+    qint32 nextId = 0;
     bool valid = false;
     QList<QQmlEngineDebugEngineReference> engines;
     QQmlEngineDebugContextReference rootContext;
diff --git a/src/qmlmodels/qqmldelegatemodel.cpp b/src/qmlmodels/qqmldelegatemodel.cpp
index e7868517c..65c99d9bc 100644
--- a/src/qmlmodels/qqmldelegatemodel.cpp
+++ b/src/qmlmodels/qqmldelegatemodel.cpp
@@ -454,7 +454,8 @@ void QQmlDelegateModel::setDelegate(QQmlComponent *delegate)
     }
     if (d->m_delegate == delegate)
         return;
-    bool wasValid = d->m_delegate != nullptr;
+    if (d->m_complete)
+        _q_itemsRemoved(0, d->m_count);
     d->m_delegate.setObject(delegate, this);
     d->m_delegateValidated = false;
     if (d->m_delegateChooser)
@@ -470,7 +471,11 @@ void QQmlDelegateModel::setDelegate(QQmlComponent *delegate)
                                                [d](){ d->delegateChanged(); });
         }
     }
-    d->delegateChanged(d->m_delegate, wasValid);
+    if (d->m_complete) {
+        _q_itemsInserted(0, d->adaptorModelCount());
+        d->requestMoreIfNecessary();
+    }
+    emit delegateChanged();
 }
 
 /*!
diff --git a/src/qmlmodels/qqmldelegatemodel_p.h b/src/qmlmodels/qqmldelegatemodel_p.h
index 21eaef02e..9e846ccc3 100644
--- a/src/qmlmodels/qqmldelegatemodel_p.h
+++ b/src/qmlmodels/qqmldelegatemodel_p.h
@@ -77,7 +77,7 @@ class Q_QMLMODELS_PRIVATE_EXPORT QQmlDelegateModel : public QQmlInstanceModel, p
     Q_DECLARE_PRIVATE(QQmlDelegateModel)
 
     Q_PROPERTY(QVariant model READ model WRITE setModel)
-    Q_PROPERTY(QQmlComponent *delegate READ delegate WRITE setDelegate)
+    Q_PROPERTY(QQmlComponent *delegate READ delegate WRITE setDelegate NOTIFY delegateChanged)
     Q_PROPERTY(QString filterOnGroup READ filterGroup WRITE setFilterGroup NOTIFY filterGroupChanged RESET resetFilterGroup)
     Q_PROPERTY(QQmlDelegateModelGroup *items READ items CONSTANT) //TODO : worth renaming?
     Q_PROPERTY(QQmlDelegateModelGroup *persistedItems READ persistedItems CONSTANT)
@@ -136,6 +136,7 @@ Q_SIGNALS:
     void filterGroupChanged();
     void defaultGroupsChanged();
     void rootIndexChanged();
+    void delegateChanged();
 
 private Q_SLOTS:
     void _q_itemsChanged(int index, int count, const QVector<int> &roles);
diff --git a/src/qmlmodels/qqmllistmodel.cpp b/src/qmlmodels/qqmllistmodel.cpp
index 1cd089f45..e0a66e717 100644
--- a/src/qmlmodels/qqmllistmodel.cpp
+++ b/src/qmlmodels/qqmllistmodel.cpp
@@ -634,7 +634,7 @@ void ListModel::set(int elementIndex, QV4::Object *object, QVector<int> *roles)
         mo->updateValues(*roles);
 }
 
-void ListModel::set(int elementIndex, QV4::Object *object)
+void ListModel::set(int elementIndex, QV4::Object *object, ListModel::SetElement reason)
 {
     if (!object)
         return;
@@ -684,7 +684,7 @@ void ListModel::set(int elementIndex, QV4::Object *object)
         } else if (QV4::DateObject *date = propertyValue->as<QV4::DateObject>()) {
             const ListLayout::Role &r = m_layout->getRoleOrCreate(propertyName, ListLayout::Role::DateTime);
             if (r.type == ListLayout::Role::DateTime) {
-                QDateTime dt = date->toQDateTime();;
+                QDateTime dt = date->toQDateTime();
                 e->setDateTimePropertyFast(r, dt);
             }
         } else if (QV4::Object *o = propertyValue->as<QV4::Object>()) {
@@ -699,9 +699,16 @@ void ListModel::set(int elementIndex, QV4::Object *object)
                     e->setVariantMapFast(role, o);
             }
         } else if (propertyValue->isNullOrUndefined()) {
-            const ListLayout::Role *r = m_layout->getExistingRole(propertyName);
-            if (r)
-                e->clearProperty(*r);
+            if (reason == SetElement::WasJustInserted) {
+                QQmlError err;
+                auto memberName = propertyName->toString(m_modelCache->engine())->toQString();
+                err.setDescription(QString::fromLatin1("%1 is %2. Adding an object with a %2 member does not create a role for it.").arg(memberName, propertyValue->isNull() ? QLatin1String("null") : QLatin1String("undefined")));
+                qmlWarning(nullptr, err);
+            } else {
+                const ListLayout::Role *r = m_layout->getExistingRole(propertyName);
+                if (r)
+                    e->clearProperty(*r);
+            }
         }
     }
 }
@@ -725,13 +732,13 @@ QVector<std::function<void()>> ListModel::remove(int index, int count)
 void ListModel::insert(int elementIndex, QV4::Object *object)
 {
     insertElement(elementIndex);
-    set(elementIndex, object);
+    set(elementIndex, object, SetElement::WasJustInserted);
 }
 
 int ListModel::append(QV4::Object *object)
 {
     int elementIndex = appendElement();
-    set(elementIndex, object);
+    set(elementIndex, object, SetElement::WasJustInserted);
     return elementIndex;
 }
 
@@ -1641,8 +1648,18 @@ PropertyKey ModelObjectOwnPropertyKeyIterator::next(const Object *o, Property *p
         if (attrs)
             *attrs = QV4::Attr_Data;
         if (pd) {
+
             QVariant value = that->d()->m_model->data(that->d()->elementIndex(), role.index);
-            pd->value = v4->fromVariant(value);
+            if (auto recursiveListModel = qvariant_cast<QQmlListModel*>(value)) {
+                auto size = recursiveListModel->count();
+                auto array = ScopedArrayObject{scope, v4->newArrayObject(size)};
+                for (auto i = 0; i < size; i++) {
+                    array->arrayPut(i, QJSValuePrivate::convertedToValue(v4, recursiveListModel->get(i)));
+                }
+                pd->value = array;
+            } else {
+                pd->value = v4->fromVariant(value);
+            }
         }
         return roleName->toPropertyKey();
     }
diff --git a/src/qmlmodels/qqmllistmodel_p_p.h b/src/qmlmodels/qqmllistmodel_p_p.h
index a0d0e9ad8..2ad515805 100644
--- a/src/qmlmodels/qqmllistmodel_p_p.h
+++ b/src/qmlmodels/qqmllistmodel_p_p.h
@@ -381,8 +381,10 @@ public:
         return elements.count();
     }
 
+    enum class SetElement {WasJustInserted, IsCurrentlyUpdated};
+
     void set(int elementIndex, QV4::Object *object, QVector<int> *roles);
-    void set(int elementIndex, QV4::Object *object);
+    void set(int elementIndex, QV4::Object *object, SetElement reason = SetElement::IsCurrentlyUpdated);
 
     int append(QV4::Object *object);
     void insert(int elementIndex, QV4::Object *object);
diff --git a/src/quick/doc/qtquick.qdocconf b/src/quick/doc/qtquick.qdocconf
index 6a4300c1b..91458527d 100644
--- a/src/quick/doc/qtquick.qdocconf
+++ b/src/quick/doc/qtquick.qdocconf
@@ -38,7 +38,7 @@ qhp.QtQuick.subprojects.examples.selectors = fake:example
 
 tagfile                 = ../../../doc/qtquick/qtquick.tags
 
-depends += qtcore qtqml qtqmltest qtgui qtlinguist qtquickcontrols1 qtquickcontrols qtdoc qtquickdialogs qtsensors qtwidgets qmake qtmultimedia qtgraphicaleffects qtsql qtxmlpatterns
+depends += qtcore qtqml qtqmltest qtgui qtlinguist qtquickcontrols qtquickcontrols1 qtdoc qtquickdialogs qtsensors qtwidgets qmake qtmultimedia qtgraphicaleffects qtsql qtxmlpatterns
 
 headerdirs  += ..\
                ../../quick \
diff --git a/src/quick/handlers/qquickmultipointhandler.cpp b/src/quick/handlers/qquickmultipointhandler.cpp
index 0afc9997a..f404788de 100644
--- a/src/quick/handlers/qquickmultipointhandler.cpp
+++ b/src/quick/handlers/qquickmultipointhandler.cpp
@@ -364,7 +364,7 @@ void QQuickMultiPointHandler::acceptPoints(const QVector<QQuickEventPoint *> &po
         point->setAccepted();
 }
 
-bool QQuickMultiPointHandler::grabPoints(QVector<QQuickEventPoint *> points)
+bool QQuickMultiPointHandler::grabPoints(const QVector<QQuickEventPoint *> &points)
 {
     if (points.isEmpty())
         return false;
diff --git a/src/quick/handlers/qquickmultipointhandler_p.h b/src/quick/handlers/qquickmultipointhandler_p.h
index eeb4b13b8..480f69035 100644
--- a/src/quick/handlers/qquickmultipointhandler_p.h
+++ b/src/quick/handlers/qquickmultipointhandler_p.h
@@ -107,7 +107,7 @@ protected:
     QVector<PointData> angles(const QPointF &ref) const;
     static qreal averageAngleDelta(const QVector<PointData> &old, const QVector<PointData> &newAngles);
     void acceptPoints(const QVector<QQuickEventPoint *> &points);
-    bool grabPoints(QVector<QQuickEventPoint *> points);
+    bool grabPoints(const QVector<QQuickEventPoint *> &points);
     void moveTarget(QPointF pos);
 
     Q_DECLARE_PRIVATE(QQuickMultiPointHandler)
diff --git a/src/quick/items/qquickanimatedsprite.cpp b/src/quick/items/qquickanimatedsprite.cpp
index 18adb4e99..d22e77c8a 100644
--- a/src/quick/items/qquickanimatedsprite.cpp
+++ b/src/quick/items/qquickanimatedsprite.cpp
@@ -532,7 +532,7 @@ void QQuickAnimatedSprite::setInterpolate(bool arg)
     }
 }
 
-void QQuickAnimatedSprite::setSource(QUrl arg)
+void QQuickAnimatedSprite::setSource(const QUrl &arg)
 {
     Q_D(QQuickAnimatedSprite);
 
diff --git a/src/quick/items/qquickanimatedsprite_p.h b/src/quick/items/qquickanimatedsprite_p.h
index ff59591c9..d36f908c7 100644
--- a/src/quick/items/qquickanimatedsprite_p.h
+++ b/src/quick/items/qquickanimatedsprite_p.h
@@ -122,7 +122,7 @@ Q_SIGNALS:
     void runningChanged(bool arg);
     void interpolateChanged(bool arg);
 
-    void sourceChanged(QUrl arg);
+    void sourceChanged(const QUrl &arg);
     void reverseChanged(bool arg);
     void frameSyncChanged(bool arg);
     void frameCountChanged(int arg);
@@ -148,7 +148,7 @@ public Q_SLOTS:
     void setRunning(bool arg);
     void setPaused(bool arg);
     void setInterpolate(bool arg);
-    void setSource(QUrl arg);
+    void setSource(const QUrl &arg);
     void setReverse(bool arg);
     void setFrameSync(bool arg);
     void setFrameCount(int arg);
diff --git a/src/quick/items/qquickimage.cpp b/src/quick/items/qquickimage.cpp
index c7e7ccea5..840cfe15d 100644
--- a/src/quick/items/qquickimage.cpp
+++ b/src/quick/items/qquickimage.cpp
@@ -676,13 +676,13 @@ QSGNode *QQuickImage::updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *)
 
     int xOffset = 0;
     if (d->hAlign == QQuickImage::AlignHCenter)
-        xOffset = qCeil((width() - pixWidth) / 2.);
+        xOffset = (width() - pixWidth) / 2;
     else if (d->hAlign == QQuickImage::AlignRight)
         xOffset = qCeil(width() - pixWidth);
 
     int yOffset = 0;
     if (d->vAlign == QQuickImage::AlignVCenter)
-        yOffset = qCeil((height() - pixHeight) / 2.);
+        yOffset = (height() - pixHeight) / 2;
     else if (d->vAlign == QQuickImage::AlignBottom)
         yOffset = qCeil(height() - pixHeight);
 
diff --git a/src/quick/items/qquickitemview.cpp b/src/quick/items/qquickitemview.cpp
index bbfbf6244..fccd46727 100644
--- a/src/quick/items/qquickitemview.cpp
+++ b/src/quick/items/qquickitemview.cpp
@@ -247,6 +247,8 @@ void QQuickItemView::setModel(const QVariant &m)
 
         connect(d->model, SIGNAL(modelUpdated(QQmlChangeSet,bool)),
                 this, SLOT(modelUpdated(QQmlChangeSet,bool)));
+        if (QQmlDelegateModel *dataModel = qobject_cast<QQmlDelegateModel*>(d->model))
+            QObjectPrivate::connect(dataModel, &QQmlDelegateModel::delegateChanged, d, &QQuickItemViewPrivate::applyDelegateChange);
         emit countChanged();
     }
     emit modelChanged();
@@ -277,22 +279,8 @@ void QQuickItemView::setDelegate(QQmlComponent *delegate)
     if (QQmlDelegateModel *dataModel = qobject_cast<QQmlDelegateModel*>(d->model)) {
         int oldCount = dataModel->count();
         dataModel->setDelegate(delegate);
-        if (isComponentComplete()) {
-            d->releaseVisibleItems();
-            d->releaseItem(d->currentItem);
-            d->currentItem = nullptr;
-            d->updateSectionCriteria();
-            d->refill();
-            d->moveReason = QQuickItemViewPrivate::SetIndex;
-            d->updateCurrent(d->currentIndex);
-            if (d->highlight && d->currentItem) {
-                if (d->autoHighlight)
-                    d->resetHighlightPosition();
-                d->updateTrackedItem();
-            }
-            d->moveReason = QQuickItemViewPrivate::Other;
-            d->updateViewport();
-        }
+        if (isComponentComplete())
+            d->applyDelegateChange();
         if (oldCount != dataModel->count())
             emit countChanged();
     }
@@ -599,6 +587,7 @@ void QQuickItemView::setHighlightRangeMode(HighlightRangeMode mode)
     d->haveHighlightRange = d->highlightRange != NoHighlightRange && d->highlightRangeStart <= d->highlightRangeEnd;
     if (isComponentComplete()) {
         d->updateViewport();
+        d->moveReason = QQuickItemViewPrivate::Other;
         d->fixupPosition();
     }
     emit highlightRangeModeChanged();
@@ -621,8 +610,10 @@ void QQuickItemView::setPreferredHighlightBegin(qreal start)
     d->haveHighlightRange = d->highlightRange != NoHighlightRange && d->highlightRangeStart <= d->highlightRangeEnd;
     if (isComponentComplete()) {
         d->updateViewport();
-        if (!isMoving() && !isFlicking())
+        if (!isMoving() && !isFlicking()) {
+            d->moveReason = QQuickItemViewPrivate::Other;
             d->fixupPosition();
+        }
     }
     emit preferredHighlightBeginChanged();
 }
@@ -636,8 +627,10 @@ void QQuickItemView::resetPreferredHighlightBegin()
     d->highlightRangeStart = 0;
     if (isComponentComplete()) {
         d->updateViewport();
-        if (!isMoving() && !isFlicking())
+        if (!isMoving() && !isFlicking()) {
+            d->moveReason = QQuickItemViewPrivate::Other;
             d->fixupPosition();
+        }
     }
     emit preferredHighlightBeginChanged();
 }
@@ -658,8 +651,10 @@ void QQuickItemView::setPreferredHighlightEnd(qreal end)
     d->haveHighlightRange = d->highlightRange != NoHighlightRange && d->highlightRangeStart <= d->highlightRangeEnd;
     if (isComponentComplete()) {
         d->updateViewport();
-        if (!isMoving() && !isFlicking())
+        if (!isMoving() && !isFlicking()) {
+            d->moveReason = QQuickItemViewPrivate::Other;
             d->fixupPosition();
+        }
     }
     emit preferredHighlightEndChanged();
 }
@@ -673,8 +668,10 @@ void QQuickItemView::resetPreferredHighlightEnd()
     d->highlightRangeEnd = 0;
     if (isComponentComplete()) {
         d->updateViewport();
-        if (!isMoving() && !isFlicking())
+        if (!isMoving() && !isFlicking()) {
+            d->moveReason = QQuickItemViewPrivate::Other;
             d->fixupPosition();
+        }
     }
     emit preferredHighlightEndChanged();
 }
@@ -1089,6 +1086,24 @@ qreal QQuickItemViewPrivate::calculatedMaxExtent() const
     return maxExtent;
 }
 
+void QQuickItemViewPrivate::applyDelegateChange()
+{
+    releaseVisibleItems();
+    releaseItem(currentItem);
+    currentItem = nullptr;
+    updateSectionCriteria();
+    refill();
+    moveReason = QQuickItemViewPrivate::SetIndex;
+    updateCurrent(currentIndex);
+    if (highlight && currentItem) {
+        if (autoHighlight)
+            resetHighlightPosition();
+        updateTrackedItem();
+    }
+    moveReason = QQuickItemViewPrivate::Other;
+    updateViewport();
+}
+
 // for debugging only
 void QQuickItemViewPrivate::checkVisible() const
 {
diff --git a/src/quick/items/qquickitemview_p_p.h b/src/quick/items/qquickitemview_p_p.h
index ef674f0fc..860cf5fa2 100644
--- a/src/quick/items/qquickitemview_p_p.h
+++ b/src/quick/items/qquickitemview_p_p.h
@@ -191,6 +191,8 @@ public:
     qreal calculatedMinExtent() const;
     qreal calculatedMaxExtent() const;
 
+    void applyDelegateChange();
+
     void applyPendingChanges();
     bool applyModelChanges(ChangeResult *insertionResult, ChangeResult *removalResult);
     bool applyRemovalChange(const QQmlChangeSet::Change &removal, ChangeResult *changeResult, int *removedCount);
diff --git a/src/quick/items/qquickopenglshadereffect.cpp b/src/quick/items/qquickopenglshadereffect.cpp
index 0fd7df893..e217fdb5d 100644
--- a/src/quick/items/qquickopenglshadereffect.cpp
+++ b/src/quick/items/qquickopenglshadereffect.cpp
@@ -189,8 +189,8 @@ class MappedSlotObject: public QtPrivate::QSlotObjectBase
 public:
     typedef std::function<void()> PropChangedFunc;
 
-    explicit MappedSlotObject(PropChangedFunc func)
-        : QSlotObjectBase(&impl), _signalIndex(-1), func(func)
+    explicit MappedSlotObject(PropChangedFunc f)
+        : QSlotObjectBase(&impl), _signalIndex(-1), func(std::move(f))
     { ref(); }
 
     void setSignalIndex(int idx) { _signalIndex = idx; }
diff --git a/src/quick/items/qquickrendercontrol.cpp b/src/quick/items/qquickrendercontrol.cpp
index addd52cb1..9f9777f19 100644
--- a/src/quick/items/qquickrendercontrol.cpp
+++ b/src/quick/items/qquickrendercontrol.cpp
@@ -275,6 +275,7 @@ void QQuickRenderControl::polishItems()
     if (!d->window)
         return;
     cd->polishItems();
+    emit d->window->afterAnimating();
 }
 
 /*!
diff --git a/src/quick/items/qquickstateoperations.cpp b/src/quick/items/qquickstateoperations.cpp
index fe1dfd349..31d1c9164 100644
--- a/src/quick/items/qquickstateoperations.cpp
+++ b/src/quick/items/qquickstateoperations.cpp
@@ -200,7 +200,7 @@ QQmlScriptString QQuickParentChange::x() const
     return d->xString.value;
 }
 
-void QQuickParentChange::setX(QQmlScriptString x)
+void QQuickParentChange::setX(const QQmlScriptString &x)
 {
     Q_D(QQuickParentChange);
     d->xString = x;
@@ -218,7 +218,7 @@ QQmlScriptString QQuickParentChange::y() const
     return d->yString.value;
 }
 
-void QQuickParentChange::setY(QQmlScriptString y)
+void QQuickParentChange::setY(const QQmlScriptString &y)
 {
     Q_D(QQuickParentChange);
     d->yString = y;
@@ -236,7 +236,7 @@ QQmlScriptString QQuickParentChange::width() const
     return d->widthString.value;
 }
 
-void QQuickParentChange::setWidth(QQmlScriptString width)
+void QQuickParentChange::setWidth(const QQmlScriptString &width)
 {
     Q_D(QQuickParentChange);
     d->widthString = width;
@@ -254,7 +254,7 @@ QQmlScriptString QQuickParentChange::height() const
     return d->heightString.value;
 }
 
-void QQuickParentChange::setHeight(QQmlScriptString height)
+void QQuickParentChange::setHeight(const QQmlScriptString &height)
 {
     Q_D(QQuickParentChange);
     d->heightString = height;
@@ -272,7 +272,7 @@ QQmlScriptString QQuickParentChange::scale() const
     return d->scaleString.value;
 }
 
-void QQuickParentChange::setScale(QQmlScriptString scale)
+void QQuickParentChange::setScale(const QQmlScriptString &scale)
 {
     Q_D(QQuickParentChange);
     d->scaleString = scale;
@@ -290,7 +290,7 @@ QQmlScriptString QQuickParentChange::rotation() const
     return d->rotationString.value;
 }
 
-void QQuickParentChange::setRotation(QQmlScriptString rotation)
+void QQuickParentChange::setRotation(const QQmlScriptString &rotation)
 {
     Q_D(QQuickParentChange);
     d->rotationString = rotation;
diff --git a/src/quick/items/qquickstateoperations_p.h b/src/quick/items/qquickstateoperations_p.h
index e947b2213..357366bc6 100644
--- a/src/quick/items/qquickstateoperations_p.h
+++ b/src/quick/items/qquickstateoperations_p.h
@@ -87,27 +87,27 @@ public:
     QQuickItem *originalParent() const;
 
     QQmlScriptString x() const;
-    void setX(QQmlScriptString x);
+    void setX(const QQmlScriptString &x);
     bool xIsSet() const;
 
     QQmlScriptString y() const;
-    void setY(QQmlScriptString y);
+    void setY(const QQmlScriptString &y);
     bool yIsSet() const;
 
     QQmlScriptString width() const;
-    void setWidth(QQmlScriptString width);
+    void setWidth(const QQmlScriptString &width);
     bool widthIsSet() const;
 
     QQmlScriptString height() const;
-    void setHeight(QQmlScriptString height);
+    void setHeight(const QQmlScriptString &height);
     bool heightIsSet() const;
 
     QQmlScriptString scale() const;
-    void setScale(QQmlScriptString scale);
+    void setScale(const QQmlScriptString &scale);
     bool scaleIsSet() const;
 
     QQmlScriptString rotation() const;
-    void setRotation(QQmlScriptString rotation);
+    void setRotation(const QQmlScriptString &rotation);
     bool rotationIsSet() const;
 
     ActionList actions() override;
diff --git a/src/quick/items/qquicktableview.cpp b/src/quick/items/qquicktableview.cpp
index 95fac3080..295c6898b 100644
--- a/src/quick/items/qquicktableview.cpp
+++ b/src/quick/items/qquicktableview.cpp
@@ -2582,7 +2582,7 @@ QJSValue QQuickTableView::rowHeightProvider() const
     return d_func()->rowHeightProvider;
 }
 
-void QQuickTableView::setRowHeightProvider(QJSValue provider)
+void QQuickTableView::setRowHeightProvider(const QJSValue &provider)
 {
     Q_D(QQuickTableView);
     if (provider.strictlyEquals(d->rowHeightProvider))
@@ -2598,7 +2598,7 @@ QJSValue QQuickTableView::columnWidthProvider() const
     return d_func()->columnWidthProvider;
 }
 
-void QQuickTableView::setColumnWidthProvider(QJSValue provider)
+void QQuickTableView::setColumnWidthProvider(const QJSValue &provider)
 {
     Q_D(QQuickTableView);
     if (provider.strictlyEquals(d->columnWidthProvider))
diff --git a/src/quick/items/qquicktableview_p.h b/src/quick/items/qquicktableview_p.h
index 3b113efa4..a5f727d7a 100644
--- a/src/quick/items/qquicktableview_p.h
+++ b/src/quick/items/qquicktableview_p.h
@@ -95,10 +95,10 @@ public:
     void setColumnSpacing(qreal spacing);
 
     QJSValue rowHeightProvider() const;
-    void setRowHeightProvider(QJSValue provider);
+    void setRowHeightProvider(const QJSValue &provider);
 
     QJSValue columnWidthProvider() const;
-    void setColumnWidthProvider(QJSValue provider);
+    void setColumnWidthProvider(const QJSValue &provider);
 
     virtual QVariant model() const;
     virtual void setModel(const QVariant &newModel);
diff --git a/src/quick/items/qquicktextcontrol.cpp b/src/quick/items/qquicktextcontrol.cpp
index ab3b0c460..3c392be75 100644
--- a/src/quick/items/qquicktextcontrol.cpp
+++ b/src/quick/items/qquicktextcontrol.cpp
@@ -1212,8 +1212,8 @@ void QQuickTextControlPrivate::mouseReleaseEvent(QMouseEvent *e, const QPointF &
         QTextBlock block = q->blockWithMarkerAt(pos);
         if (block == blockWithMarkerUnderMousePress) {
             auto fmt = block.blockFormat();
-            fmt.setMarker(fmt.marker() == QTextBlockFormat::Unchecked ?
-                              QTextBlockFormat::Checked : QTextBlockFormat::Unchecked);
+            fmt.setMarker(fmt.marker() == QTextBlockFormat::MarkerType::Unchecked ?
+                              QTextBlockFormat::MarkerType::Checked : QTextBlockFormat::MarkerType::Unchecked);
             cursor.setBlockFormat(fmt);
         }
     }
@@ -1397,7 +1397,7 @@ QVariant QQuickTextControl::inputMethodQuery(Qt::InputMethodQuery property) cons
     return inputMethodQuery(property, QVariant());
 }
 
-QVariant QQuickTextControl::inputMethodQuery(Qt::InputMethodQuery property, QVariant argument) const
+QVariant QQuickTextControl::inputMethodQuery(Qt::InputMethodQuery property, const QVariant &argument) const
 {
     Q_D(const QQuickTextControl);
     QTextBlock block = d->cursor.block();
@@ -1507,7 +1507,7 @@ void QQuickTextControlPrivate::hoverEvent(QHoverEvent *e, const QPointF &pos)
             emit q->markerHovered(block.isValid());
         hoveredMarker = block.isValid();
         if (hoveredMarker)
-            qCDebug(DBG_HOVER_TRACE) << q << e->type() << pos << "hovered marker" << block.blockFormat().marker() << block.text();
+            qCDebug(DBG_HOVER_TRACE) << q << e->type() << pos << "hovered marker" << int(block.blockFormat().marker()) << block.text();
     }
 }
 
diff --git a/src/quick/items/qquicktextcontrol_p.h b/src/quick/items/qquicktextcontrol_p.h
index 3c7d48f91..41b8ed782 100644
--- a/src/quick/items/qquicktextcontrol_p.h
+++ b/src/quick/items/qquicktextcontrol_p.h
@@ -174,7 +174,7 @@ public:
 
 #if QT_CONFIG(im)
     virtual QVariant inputMethodQuery(Qt::InputMethodQuery property) const;
-    Q_INVOKABLE QVariant inputMethodQuery(Qt::InputMethodQuery query, QVariant argument) const;
+    Q_INVOKABLE QVariant inputMethodQuery(Qt::InputMethodQuery query, const QVariant &argument) const;
 #endif
 
     virtual QMimeData *createMimeDataFromSelection() const;
diff --git a/src/quick/items/qquicktextedit.cpp b/src/quick/items/qquicktextedit.cpp
index c4e9c0d31..7d34cc3f5 100644
--- a/src/quick/items/qquicktextedit.cpp
+++ b/src/quick/items/qquicktextedit.cpp
@@ -2060,20 +2060,19 @@ QSGNode *QQuickTextEdit::updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *
             firstDirtyPos = nodeIterator->startPos();
             // ### this could be optimized if the first and last dirty nodes are not connected
             // as the intermediate text nodes would usually only need to be transformed differently.
-            int lastDirtyPos = firstDirtyPos;
+            QQuickTextNode *firstCleanNode = nullptr;
             auto it = d->textNodeMap.constEnd();
             while (it != nodeIterator) {
                 --it;
-                if (it->dirty()) {
-                    lastDirtyPos = it->startPos();
+                if (it->dirty())
                     break;
-                }
+                firstCleanNode = it->textNode();
             }
             do {
                 rootNode->removeChildNode(nodeIterator->textNode());
                 delete nodeIterator->textNode();
                 nodeIterator = d->textNodeMap.erase(nodeIterator);
-            } while (nodeIterator != d->textNodeMap.constEnd() && nodeIterator->startPos() <= lastDirtyPos);
+            } while (nodeIterator != d->textNodeMap.constEnd() && nodeIterator->textNode() != firstCleanNode);
         }
 
         // FIXME: the text decorations could probably be handled separately (only updated for affected textFrames)
diff --git a/src/quick/items/qquicktextinput.cpp b/src/quick/items/qquicktextinput.cpp
index b1ad6a1c1..a83b9beaa 100644
--- a/src/quick/items/qquicktextinput.cpp
+++ b/src/quick/items/qquicktextinput.cpp
@@ -1958,7 +1958,7 @@ QVariant QQuickTextInput::inputMethodQuery(Qt::InputMethodQuery property) const
     return inputMethodQuery(property, QVariant());
 }
 
-QVariant QQuickTextInput::inputMethodQuery(Qt::InputMethodQuery property, QVariant argument) const
+QVariant QQuickTextInput::inputMethodQuery(Qt::InputMethodQuery property, const QVariant &argument) const
 {
     Q_D(const QQuickTextInput);
     switch (property) {
@@ -2259,8 +2259,8 @@ void QQuickTextInput::remove(int start, int end)
             d->m_cursor -= qMin(d->m_cursor, end) - start;
         if (d->m_selstart > start)
             d->m_selstart -= qMin(d->m_selstart, end) - start;
-        if (d->m_selend > end)
-            d->m_selend -= qMin(d->m_selend, end) - start;
+        if (d->m_selend >= end)
+            d->m_selend -= end - start;
     }
     d->addCommand(QQuickTextInputPrivate::Command(
             QQuickTextInputPrivate::SetSelection, d->m_cursor, 0, d->m_selstart, d->m_selend));
diff --git a/src/quick/items/qquicktextinput_p.h b/src/quick/items/qquicktextinput_p.h
index 92f3aa62c..c10b06d02 100644
--- a/src/quick/items/qquicktextinput_p.h
+++ b/src/quick/items/qquicktextinput_p.h
@@ -268,7 +268,7 @@ public:
 
 #if QT_CONFIG(im)
     QVariant inputMethodQuery(Qt::InputMethodQuery property) const override;
-    Q_REVISION(4) Q_INVOKABLE QVariant inputMethodQuery(Qt::InputMethodQuery query, QVariant argument) const;
+    Q_REVISION(4) Q_INVOKABLE QVariant inputMethodQuery(Qt::InputMethodQuery query, const QVariant &argument) const;
 #endif
 
     QRectF boundingRect() const override;
diff --git a/src/quick/items/qquicktextnodeengine.cpp b/src/quick/items/qquicktextnodeengine.cpp
index 7af90f0f8..a0ae4e5f9 100644
--- a/src/quick/items/qquicktextnodeengine.cpp
+++ b/src/quick/items/qquicktextnodeengine.cpp
@@ -638,7 +638,7 @@ void QQuickTextNodeEngine::addBorder(const QRectF &rect, qreal border,
                                      QTextFrameFormat::BorderStyle borderStyle,
                                      const QBrush &borderBrush)
 {
-    QColor color = borderBrush.color();
+    const QColor &color = borderBrush.color();
 
     // Currently we don't support other styles than solid
     Q_UNUSED(borderStyle);
@@ -1012,13 +1012,13 @@ void QQuickTextNodeEngine::addTextBlock(QTextDocument *textDocument, const QText
             };
 
             switch (block.blockFormat().marker()) {
-            case QTextBlockFormat::Checked:
+            case QTextBlockFormat::MarkerType::Checked:
                 listItemBullet = QChar(0x2612); // Checked checkbox
                 break;
-            case QTextBlockFormat::Unchecked:
+            case QTextBlockFormat::MarkerType::Unchecked:
                 listItemBullet = QChar(0x2610); // Unchecked checkbox
                 break;
-            case QTextBlockFormat::NoMarker:
+            case QTextBlockFormat::MarkerType::NoMarker:
                 break;
             }
 
diff --git a/src/quick/items/qquickwindow.cpp b/src/quick/items/qquickwindow.cpp
index 98f5d8a8c..8fb023cf6 100644
--- a/src/quick/items/qquickwindow.cpp
+++ b/src/quick/items/qquickwindow.cpp
@@ -102,6 +102,7 @@ Q_LOGGING_CATEGORY(DBG_DIRTY, "qt.quick.dirty")
 Q_LOGGING_CATEGORY(lcTransient, "qt.quick.window.transient")
 
 extern Q_GUI_EXPORT QImage qt_gl_read_framebuffer(const QSize &size, bool alpha_format, bool include_alpha);
+extern Q_GUI_EXPORT bool qt_sendShortcutOverrideEvent(QObject *o, ulong timestamp, int k, Qt::KeyboardModifiers mods, const QString &text = QString(), bool autorep = false, ushort count = 1);
 
 bool QQuickWindowPrivate::defaultAlphaBuffer = false;
 
@@ -424,6 +425,13 @@ void QQuickWindowPrivate::syncSceneGraph()
 {
     Q_Q(QQuickWindow);
 
+    // Calculate the dpr the same way renderSceneGraph() will.
+    qreal devicePixelRatio = q->effectiveDevicePixelRatio();
+    if (renderTargetId && !QQuickRenderControl::renderWindowFor(q))
+        devicePixelRatio = 1;
+
+    context->prepareSync(devicePixelRatio);
+
     animationController->beforeNodeSync();
 
     emit q->beforeSynchronizing();
@@ -1787,6 +1795,13 @@ void QQuickWindowPrivate::deliverKeyEvent(QKeyEvent *e)
 {
     if (activeFocusItem) {
         QQuickItem *item = activeFocusItem;
+
+        // In case of generated event, trigger ShortcutOverride event
+        if (e->type() == QEvent::KeyPress && e->spontaneous() == false)
+                qt_sendShortcutOverrideEvent(item, e->timestamp(),
+                                         e->key(), e->modifiers(), e->text(),
+                                         e->isAutoRepeat(), e->count());
+
         e->accept();
         QCoreApplication::sendEvent(item, e);
         while (!e->isAccepted() && (item = item->parentItem())) {
@@ -2761,7 +2776,7 @@ void QQuickWindowPrivate::deliverMatchingPointsToItem(QQuickItem *item, QQuickPo
         // If the touch was accepted (regardless by whom or in what form),
         // update accepted new points.
         bool isPressOrRelease = pointerEvent->isPressEvent() || pointerEvent->isReleaseEvent();
-        for (auto point: qAsConst(touchEvent->touchPoints())) {
+        for (const auto &point: qAsConst(touchEvent->touchPoints())) {
             if (auto pointerEventPoint = ptEvent->pointById(point.id())) {
                 pointerEventPoint->setAccepted();
                 if (isPressOrRelease)
@@ -2771,7 +2786,7 @@ void QQuickWindowPrivate::deliverMatchingPointsToItem(QQuickItem *item, QQuickPo
     } else {
         // But if the event was not accepted then we know this item
         // will not be interested in further updates for those touchpoint IDs either.
-        for (auto point: qAsConst(touchEvent->touchPoints())) {
+        for (const auto &point: qAsConst(touchEvent->touchPoints())) {
             if (point.state() == Qt::TouchPointPressed) {
                 if (auto *tp = ptEvent->pointById(point.id())) {
                     if (tp->exclusiveGrabber() == item) {
@@ -2813,32 +2828,49 @@ void QQuickWindowPrivate::deliverDragEvent(QQuickDragGrabber *grabber, QEvent *e
             for (; grabItem != grabber->end(); grabItem = grabber->release(grabItem))
                 QCoreApplication::sendEvent(**grabItem, &leaveEvent);
             return;
-        } else for (; grabItem != grabber->end(); grabItem = grabber->release(grabItem)) {
+        } else {
             QDragMoveEvent *moveEvent = static_cast<QDragMoveEvent *>(event);
-            if (deliverDragEvent(grabber, **grabItem, moveEvent)) {
-                for (++grabItem; grabItem != grabber->end();) {
-                    QPointF p = (**grabItem)->mapFromScene(moveEvent->pos());
-                    if ((**grabItem)->contains(p)) {
-                        QDragMoveEvent translatedEvent(
-                                p.toPoint(),
-                                moveEvent->possibleActions(),
-                                moveEvent->mimeData(),
-                                moveEvent->mouseButtons(),
-                                moveEvent->keyboardModifiers());
-                        QQuickDropEventEx::copyActions(&translatedEvent, *moveEvent);
-                        QCoreApplication::sendEvent(**grabItem, &translatedEvent);
-                        ++grabItem;
-                    } else {
-                        QDragLeaveEvent leaveEvent;
-                        QCoreApplication::sendEvent(**grabItem, &leaveEvent);
-                        grabItem = grabber->release(grabItem);
-                    }
+
+            // Used to ensure we don't send DragEnterEvents to current drop targets,
+            // and to detect which current drop targets we have left
+            QVarLengthArray<QQuickItem*, 64> currentGrabItems;
+            for (; grabItem != grabber->end(); grabItem = grabber->release(grabItem))
+                currentGrabItems.append(**grabItem);
+
+            // Look for any other potential drop targets that are higher than the current ones
+            QDragEnterEvent enterEvent(
+                    moveEvent->pos(),
+                    moveEvent->possibleActions(),
+                    moveEvent->mimeData(),
+                    moveEvent->mouseButtons(),
+                    moveEvent->keyboardModifiers());
+            QQuickDropEventEx::copyActions(&enterEvent, *moveEvent);
+            event->setAccepted(deliverDragEvent(grabber, contentItem, &enterEvent, &currentGrabItems));
+
+            for (grabItem = grabber->begin(); grabItem != grabber->end(); ++grabItem) {
+                int i = currentGrabItems.indexOf(**grabItem);
+                if (i >= 0) {
+                    currentGrabItems.remove(i);
+                    // Still grabbed: send move event
+                    QDragMoveEvent translatedEvent(
+                            (**grabItem)->mapFromScene(moveEvent->pos()).toPoint(),
+                            moveEvent->possibleActions(),
+                            moveEvent->mimeData(),
+                            moveEvent->mouseButtons(),
+                            moveEvent->keyboardModifiers());
+                    QQuickDropEventEx::copyActions(&translatedEvent, *moveEvent);
+                    QCoreApplication::sendEvent(**grabItem, &translatedEvent);
+                    event->setAccepted(translatedEvent.isAccepted());
+                    QQuickDropEventEx::copyActions(moveEvent, translatedEvent);
                 }
-                return;
-            } else {
-                QDragLeaveEvent leaveEvent;
-                QCoreApplication::sendEvent(**grabItem, &leaveEvent);
             }
+
+            // Anything left in currentGrabItems is no longer a drop target and should be sent a DragLeaveEvent
+            QDragLeaveEvent leaveEvent;
+            for (QQuickItem *i : currentGrabItems)
+                QCoreApplication::sendEvent(i, &leaveEvent);
+
+            return;
         }
     }
     if (event->type() == QEvent::DragEnter || event->type() == QEvent::DragMove) {
@@ -2854,9 +2886,8 @@ void QQuickWindowPrivate::deliverDragEvent(QQuickDragGrabber *grabber, QEvent *e
     }
 }
 
-bool QQuickWindowPrivate::deliverDragEvent(QQuickDragGrabber *grabber, QQuickItem *item, QDragMoveEvent *event)
+bool QQuickWindowPrivate::deliverDragEvent(QQuickDragGrabber *grabber, QQuickItem *item, QDragMoveEvent *event, QVarLengthArray<QQuickItem*, 64> *currentGrabItems)
 {
-    bool accepted = false;
     QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
     if (!item->isVisible() || !item->isEnabled() || QQuickItemPrivate::get(item)->culled)
         return false;
@@ -2875,12 +2906,24 @@ bool QQuickWindowPrivate::deliverDragEvent(QQuickDragGrabber *grabber, QQuickIte
             event->keyboardModifiers());
     QQuickDropEventEx::copyActions(&enterEvent, *event);
     QList<QQuickItem *> children = itemPrivate->paintOrderChildItems();
+
+    // Check children in front of this item first
     for (int ii = children.count() - 1; ii >= 0; --ii) {
-        if (deliverDragEvent(grabber, children.at(ii), &enterEvent))
+        if (children.at(ii)->z() < 0)
+            continue;
+        if (deliverDragEvent(grabber, children.at(ii), &enterEvent, currentGrabItems))
             return true;
     }
 
     if (itemContained) {
+        // If this item is currently grabbed, don't send it another DragEnter,
+        // just grab it again if it's still contained.
+        if (currentGrabItems && currentGrabItems->contains(item)) {
+            grabber->grab(item);
+            grabber->setTarget(item);
+            return true;
+        }
+
         if (event->type() == QEvent::DragMove || itemPrivate->flags & QQuickItem::ItemAcceptsDrops) {
             QDragMoveEvent translatedEvent(
                     p.toPoint(),
@@ -2897,15 +2940,24 @@ bool QQuickWindowPrivate::deliverDragEvent(QQuickDragGrabber *grabber, QQuickIte
             if (event->type() == QEvent::DragEnter) {
                 if (translatedEvent.isAccepted()) {
                     grabber->grab(item);
-                    accepted = true;
+                    grabber->setTarget(item);
+                    return true;
                 }
             } else {
-                accepted = true;
+                return true;
             }
         }
     }
 
-    return accepted;
+    // Check children behind this item if this item or any higher children have not accepted
+    for (int ii = children.count() - 1; ii >= 0; --ii) {
+        if (children.at(ii)->z() >= 0)
+            continue;
+        if (deliverDragEvent(grabber, children.at(ii), &enterEvent, currentGrabItems))
+            return true;
+    }
+
+    return false;
 }
 #endif // quick_draganddrop
 
@@ -3012,7 +3064,7 @@ bool QQuickWindowPrivate::sendFilteredPointerEventImpl(QQuickPointerEvent *event
                     if (filteringParent->childMouseEventFilter(receiver, filteringParentTouchEvent.data())) {
                         qCDebug(DBG_TOUCH) << "touch event intercepted by childMouseEventFilter of " << filteringParent;
                         skipDelivery.append(filteringParent);
-                        for (auto point: qAsConst(filteringParentTouchEvent->touchPoints())) {
+                        for (const auto &point: qAsConst(filteringParentTouchEvent->touchPoints())) {
                             QQuickEventPoint *pt = event->pointById(point.id());
                             pt->setAccepted();
                             pt->setGrabberItem(filteringParent);
@@ -4157,16 +4209,18 @@ QQmlIncubationController *QQuickWindow::incubationController() const
     The OpenGL context used for rendering the scene graph will be bound
     at this point.
 
-    When using the RHI and a graphics API other than OpenGL, the signal is
-    emitted after the preparations for the frame have been done, meaning there
-    is a command buffer in recording mode, where applicable. If desired, the
-    slot function connected to this signal can query native resources like the
-    command before via QSGRendererInterface. Note however that the recording of
-    the main render pass is not yet started at this point and it is not
-    possible to add commands within that pass. Instead, use
-    beforeRenderPassRecording() for that. However, connecting to this signal is
-    still important if the recording of copy type of commands is desired since
-    those cannot be enqueued within a render pass.
+    When using the RHI, the signal is emitted after the preparations for the
+    frame have been done, meaning there is a command buffer in recording mode,
+    where applicable. If desired, the slot function connected to this signal
+    can query native resources like the command before via
+    QSGRendererInterface. Note however that the recording of the main render
+    pass is not yet started at this point and it is not possible to add
+    commands within that pass. Starting a pass means clearing the color, depth,
+    and stencil buffers so it is not possible to achieve an underlay type of
+    rendering by just connecting to this signal. Rather, connect to
+    beforeRenderPassRecording(). However, connecting to this signal is still
+    important if the recording of copy type of commands is desired since those
+    cannot be enqueued within a render pass.
 
     \warning This signal is emitted from the scene graph rendering thread. If your
     slot function needs to finish before execution continues, you must make sure that
@@ -4189,18 +4243,17 @@ QQmlIncubationController *QQuickWindow::incubationController() const
 
     The OpenGL context used for rendering the scene graph will be bound at this point.
 
-    When using the RHI and a graphics API other than OpenGL, the signal is
-    emitted after scene graph has added its commands to the command buffer,
-    which is not yet submitted to the graphics queue. If desired, the slot
-    function connected to this signal can query native resources, like the
-    command buffer, before via QSGRendererInterface. Note however that the
-    render pass (or passes) are already recorded at this point and it is not
-    possible to add more commands within the scenegraph's pass. Instead, use
-    afterRenderPassRecording() for that. This signal has therefore limited use
-    and is rarely needed in an RHI-based setup. Rather, it is the combination
-    of beforeRendering() + beforeRenderPassRecording() or beforeRendering() +
-    afterRenderPassRecording() that is typically used to achieve under- or
-    overlaying of the custom rendering.
+    When using the RHI, the signal is emitted after scene graph has added its
+    commands to the command buffer, which is not yet submitted to the graphics
+    queue. If desired, the slot function connected to this signal can query
+    native resources, like the command buffer, before via QSGRendererInterface.
+    Note however that the render pass (or passes) are already recorded at this
+    point and it is not possible to add more commands within the scenegraph's
+    pass. Instead, use afterRenderPassRecording() for that. This signal has
+    therefore limited use and is rarely needed in an RHI-based setup. Rather,
+    it is the combination of beforeRendering() + beforeRenderPassRecording() or
+    beforeRendering() + afterRenderPassRecording() that is typically used to
+    achieve under- or overlaying of the custom rendering.
 
     \warning This signal is emitted from the scene graph rendering thread. If your
     slot function needs to finish before execution continues, you must make sure that
diff --git a/src/quick/items/qquickwindow_p.h b/src/quick/items/qquickwindow_p.h
index 7d1767c40..165859b5f 100644
--- a/src/quick/items/qquickwindow_p.h
+++ b/src/quick/items/qquickwindow_p.h
@@ -192,7 +192,7 @@ public:
 
 #if QT_CONFIG(quick_draganddrop)
     void deliverDragEvent(QQuickDragGrabber *, QEvent *);
-    bool deliverDragEvent(QQuickDragGrabber *, QQuickItem *, QDragMoveEvent *);
+    bool deliverDragEvent(QQuickDragGrabber *, QQuickItem *, QDragMoveEvent *, QVarLengthArray<QQuickItem*, 64> *currentGrabItems = nullptr);
 #endif
 #if QT_CONFIG(cursor)
     void updateCursor(const QPointF &scenePos);
diff --git a/src/quick/scenegraph/adaptations/software/qsgsoftwarespritenode.cpp b/src/quick/scenegraph/adaptations/software/qsgsoftwarespritenode.cpp
index d4e5e98d6..17e8bdc2f 100644
--- a/src/quick/scenegraph/adaptations/software/qsgsoftwarespritenode.cpp
+++ b/src/quick/scenegraph/adaptations/software/qsgsoftwarespritenode.cpp
@@ -49,6 +49,11 @@ QSGSoftwareSpriteNode::QSGSoftwareSpriteNode()
     setGeometry((QSGGeometry*)1);
 }
 
+QSGSoftwareSpriteNode::~QSGSoftwareSpriteNode()
+{
+    delete m_texture;
+}
+
 void QSGSoftwareSpriteNode::setTexture(QSGTexture *texture)
 {
     m_texture = qobject_cast<QSGSoftwarePixmapTexture*>(texture);
diff --git a/src/quick/scenegraph/adaptations/software/qsgsoftwarespritenode_p.h b/src/quick/scenegraph/adaptations/software/qsgsoftwarespritenode_p.h
index 577a30c05..401553739 100644
--- a/src/quick/scenegraph/adaptations/software/qsgsoftwarespritenode_p.h
+++ b/src/quick/scenegraph/adaptations/software/qsgsoftwarespritenode_p.h
@@ -64,6 +64,7 @@ class QSGSoftwareSpriteNode : public QSGSpriteNode
 {
 public:
     QSGSoftwareSpriteNode();
+    ~QSGSoftwareSpriteNode() override;
 
     void setTexture(QSGTexture *texture) override;
     void setTime(float time) override;
@@ -81,7 +82,7 @@ public:
 
 private:
 
-    QSGSoftwarePixmapTexture *m_texture;
+    QSGSoftwarePixmapTexture *m_texture = nullptr;
     float m_time;
     QPoint m_sourceA;
     QPoint m_sourceB;
diff --git a/src/quick/scenegraph/compressedtexture/qsgcompressedatlastexture.cpp b/src/quick/scenegraph/compressedtexture/qsgcompressedatlastexture.cpp
index d3dc4978f..46b2c6386 100644
--- a/src/quick/scenegraph/compressedtexture/qsgcompressedatlastexture.cpp
+++ b/src/quick/scenegraph/compressedtexture/qsgcompressedatlastexture.cpp
@@ -88,10 +88,20 @@ Texture *Atlas::create(const QByteArray &data, int dataLength, int dataOffset, c
 
 void Atlas::generateTexture()
 {
+    int bytesPerBlock = 8;
+    switch (m_format) {
+    case QOpenGLTexture::RGBA8_ETC2_EAC:
+    case QOpenGLTexture::RGBA_DXT3:
+    case QOpenGLTexture::RGBA_DXT5:
+        bytesPerBlock = 16;
+    default:
+        break;
+    }
+
     QOpenGLFunctions *funcs = QOpenGLContext::currentContext()->functions();
     funcs->glCompressedTexImage2D(GL_TEXTURE_2D, 0, m_format,
                                   m_size.width(), m_size.height(), 0,
-                                  (m_size.width() * m_size.height()) / 2,
+                                  (m_size.width() / 4 * m_size.height() / 4) * bytesPerBlock,
                                   nullptr);
 }
 
diff --git a/src/quick/scenegraph/coreapi/qsgbatchrenderer.cpp b/src/quick/scenegraph/coreapi/qsgbatchrenderer.cpp
index 37deaa35d..34027cbac 100644
--- a/src/quick/scenegraph/coreapi/qsgbatchrenderer.cpp
+++ b/src/quick/scenegraph/coreapi/qsgbatchrenderer.cpp
@@ -187,7 +187,7 @@ static QRhiVertexInputLayout calculateVertexInputLayout(const QSGMaterialRhiShad
     }
 
     const int attrCount = geometry->attributeCount();
-    QVector<QRhiVertexInputAttribute> inputAttributes;
+    QVarLengthArray<QRhiVertexInputAttribute, 8> inputAttributes;
     inputAttributes.reserve(attrCount + 1);
     int offset = 0;
     for (int i = 0; i < attrCount; ++i) {
@@ -205,15 +205,14 @@ static QRhiVertexInputLayout calculateVertexInputLayout(const QSGMaterialRhiShad
     }
 
     Q_ASSERT(VERTEX_BUFFER_BINDING == 0 && ZORDER_BUFFER_BINDING == 1); // not very flexible
-    QVector<QRhiVertexInputBinding> inputBindings;
-    inputBindings.reserve(2);
+    QVarLengthArray<QRhiVertexInputBinding, 2> inputBindings;
     inputBindings.append(QRhiVertexInputBinding(geometry->sizeOfVertex()));
     if (batchable)
         inputBindings.append(QRhiVertexInputBinding(sizeof(float)));
 
     QRhiVertexInputLayout inputLayout;
-    inputLayout.setBindings(inputBindings);
-    inputLayout.setAttributes(inputAttributes);
+    inputLayout.setBindings(inputBindings.cbegin(), inputBindings.cend());
+    inputLayout.setAttributes(inputAttributes.cbegin(), inputAttributes.cend());
 
     return inputLayout;
 }
@@ -400,14 +399,14 @@ void ShaderManager::clearCachedRendererData()
     }
 }
 
-QRhiShaderResourceBindings *ShaderManager::srb(const QVector<QRhiShaderResourceBinding> &bindings)
+QRhiShaderResourceBindings *ShaderManager::srb(const ShaderResourceBindingList &bindings)
 {
     auto it = srbCache.constFind(bindings);
     if (it != srbCache.constEnd())
         return *it;
 
     QRhiShaderResourceBindings *srb = context->rhi()->newShaderResourceBindings();
-    srb->setBindings(bindings);
+    srb->setBindings(bindings.cbegin(), bindings.cend());
     if (srb->build()) {
         srbCache.insert(bindings, srb);
     } else {
@@ -2849,7 +2848,7 @@ void Renderer::updateClipState(const QSGClipNode *clipList, Batch *batch) // RHI
             else {
                 if (qsg_topology(g->drawingMode()) != m_stencilClipCommon.topology)
                     qWarning("updateClipState: Clip list entries have different primitive topologies, this is not currently supported.");
-                if (qsg_vertexInputFormat(*a) != m_stencilClipCommon.inputLayout.attributes().first().format())
+                if (qsg_vertexInputFormat(*a) != m_stencilClipCommon.inputLayout.cbeginAttributes()->format())
                     qWarning("updateClipState: Clip list entries have different vertex input layouts, this is must not happen.");
             }
 #endif
@@ -3253,7 +3252,7 @@ bool Renderer::ensurePipelineState(Element *e, const ShaderManager::Shader *sms)
 
     // Build a new one. This is potentially expensive.
     QRhiGraphicsPipeline *ps = m_rhi->newGraphicsPipeline();
-    ps->setShaderStages(sms->programRhi.shaderStages);
+    ps->setShaderStages(sms->programRhi.shaderStages.cbegin(), sms->programRhi.shaderStages.cend());
     ps->setVertexInputLayout(sms->programRhi.inputLayout);
     ps->setShaderResourceBindings(e->srb);
     ps->setRenderPassDescriptor(renderPassDescriptor());
@@ -3428,7 +3427,7 @@ static void materialToRendererGraphicsState(GraphicsState *dst,
 void Renderer::updateMaterialDynamicData(ShaderManager::Shader *sms,
                                          QSGMaterialRhiShader::RenderState &renderState,
                                          QSGMaterial *material,
-                                         QVector<QRhiShaderResourceBinding> *bindings,
+                                         ShaderManager::ShaderResourceBindingList *bindings,
                                          const Batch *batch,
                                          int ubufOffset,
                                          int ubufRegionSize) // RHI only, [prepare step]
@@ -3630,7 +3629,7 @@ bool Renderer::prepareRenderMergedBatch(Batch *batch, PreparedRenderBatch *rende
     bool pendingGStatePop = false;
     updateMaterialStaticData(sms, renderState, material, batch, &pendingGStatePop);
 
-    QVector<QRhiShaderResourceBinding> bindings;
+    ShaderManager::ShaderResourceBindingList bindings;
     updateMaterialDynamicData(sms, renderState, material, &bindings, batch, 0, ubufSize);
 
 #ifndef QT_NO_DEBUG
@@ -3824,7 +3823,7 @@ bool Renderer::prepareRenderUnmergedBatch(Batch *batch, PreparedRenderBatch *ren
         }
 
         QSGMaterialRhiShader::RenderState renderState = rhiState(QSGMaterialRhiShader::RenderState::DirtyStates(int(dirty)));
-        QVector<QRhiShaderResourceBinding> bindings;
+        ShaderManager::ShaderResourceBindingList bindings;
         updateMaterialDynamicData(sms, renderState,
                                   material, &bindings, batch, ubufOffset, ubufSize);
 
diff --git a/src/quick/scenegraph/coreapi/qsgbatchrenderer_p.h b/src/quick/scenegraph/coreapi/qsgbatchrenderer_p.h
index 5390e14c7..297df2232 100644
--- a/src/quick/scenegraph/coreapi/qsgbatchrenderer_p.h
+++ b/src/quick/scenegraph/coreapi/qsgbatchrenderer_p.h
@@ -642,7 +642,7 @@ public:
         struct {
             QSGMaterialRhiShader *program = nullptr;
             QRhiVertexInputLayout inputLayout;
-            QVector<QRhiGraphicsShaderStage> shaderStages;
+            QVarLengthArray<QRhiGraphicsShaderStage, 2> shaderStages;
         } programRhi;
 
         float lastOpacity;
@@ -656,7 +656,9 @@ public:
 
     void clearCachedRendererData();
 
-    QRhiShaderResourceBindings *srb(const QVector<QRhiShaderResourceBinding> &bindings);
+    using ShaderResourceBindingList = QVarLengthArray<QRhiShaderResourceBinding, 8>;
+
+    QRhiShaderResourceBindings *srb(const ShaderResourceBindingList &bindings);
 
 public Q_SLOTS:
     void invalidated();
@@ -672,7 +674,7 @@ private:
     QOpenGLShaderProgram *blitProgram;
     QSGDefaultRenderContext *context;
 
-    QHash<QVector<QRhiShaderResourceBinding>, QRhiShaderResourceBindings *> srbCache;
+    QHash<ShaderResourceBindingList, QRhiShaderResourceBindings *> srbCache;
 };
 
 struct GraphicsState
@@ -797,7 +799,7 @@ private:
     bool ensurePipelineState(Element *e, const ShaderManager::Shader *sms);
     QRhiTexture *dummyTexture();
     void updateMaterialDynamicData(ShaderManager::Shader *sms, QSGMaterialRhiShader::RenderState &renderState,
-                                   QSGMaterial *material, QVector<QRhiShaderResourceBinding> *bindings,
+                                   QSGMaterial *material, ShaderManager::ShaderResourceBindingList *bindings,
                                    const Batch *batch, int ubufOffset, int ubufRegionSize);
     void updateMaterialStaticData(ShaderManager::Shader *sms, QSGMaterialRhiShader::RenderState &renderState,
                                   QSGMaterial *material, Batch *batch, bool *gstateChanged);
diff --git a/src/quick/scenegraph/qsgcontext.cpp b/src/quick/scenegraph/qsgcontext.cpp
index 97fd49e4c..17eb1e312 100644
--- a/src/quick/scenegraph/qsgcontext.cpp
+++ b/src/quick/scenegraph/qsgcontext.cpp
@@ -341,6 +341,11 @@ void QSGRenderContext::invalidate()
 {
 }
 
+void QSGRenderContext::prepareSync(qreal devicePixelRatio)
+{
+    Q_UNUSED(devicePixelRatio);
+}
+
 void QSGRenderContext::beginNextFrame(QSGRenderer *renderer,
                                       RenderPassCallback mainPassRecordingStart,
                                       RenderPassCallback mainPassRecordingEnd,
diff --git a/src/quick/scenegraph/qsgcontext_p.h b/src/quick/scenegraph/qsgcontext_p.h
index 4e712ab7c..244bcfabd 100644
--- a/src/quick/scenegraph/qsgcontext_p.h
+++ b/src/quick/scenegraph/qsgcontext_p.h
@@ -174,6 +174,7 @@ public:
 
     using RenderPassCallback = void (*)(void *);
 
+    virtual void prepareSync(qreal devicePixelRatio);
     virtual void beginNextFrame(QSGRenderer *renderer,
                                 RenderPassCallback mainPassRecordingStart,
                                 RenderPassCallback mainPassRecordingEnd,
diff --git a/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp b/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp
index 4eba40b7a..be6ef25fe 100644
--- a/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp
+++ b/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp
@@ -751,15 +751,15 @@ void QSGTextMaskMaterial::updateCache(QFontEngine::GlyphFormat glyphFormat)
         void *cacheKey;
         if (m_rhi) {
             cacheKey = m_rhi;
-            // ### no idea what the QWindow is (esp. since we are not even
-            // rendering at this point), and anyway is the original logic correct
-            // even...
-            devicePixelRatio = qGuiApp->devicePixelRatio();
+            // Get the dpr the modern way. This value retrieved via the
+            // rendercontext matches what RenderState::devicePixelRatio()
+            // exposes to the material shaders later on.
+            devicePixelRatio = m_rc->currentDevicePixelRatio();
         } else {
             ctx = const_cast<QOpenGLContext *>(QOpenGLContext::currentContext());
             Q_ASSERT(ctx != nullptr);
             cacheKey = ctx;
-            devicePixelRatio = qsg_device_pixel_ratio(ctx);
+            devicePixelRatio = qsg_device_pixel_ratio(ctx); // this is technically incorrect, see other branch above
         }
 
         QTransform glyphCacheTransform = QTransform::fromScale(devicePixelRatio, devicePixelRatio);
diff --git a/src/quick/scenegraph/qsgdefaultrendercontext.cpp b/src/quick/scenegraph/qsgdefaultrendercontext.cpp
index 4ccaa91cc..2bf4a83a8 100644
--- a/src/quick/scenegraph/qsgdefaultrendercontext.cpp
+++ b/src/quick/scenegraph/qsgdefaultrendercontext.cpp
@@ -200,6 +200,11 @@ void QSGDefaultRenderContext::invalidate()
     emit invalidated();
 }
 
+void QSGDefaultRenderContext::prepareSync(qreal devicePixelRatio)
+{
+    m_currentDevicePixelRatio = devicePixelRatio;
+}
+
 static QBasicMutex qsg_framerender_mutex;
 
 void QSGDefaultRenderContext::beginNextFrame(QSGRenderer *renderer,
diff --git a/src/quick/scenegraph/qsgdefaultrendercontext_p.h b/src/quick/scenegraph/qsgdefaultrendercontext_p.h
index 6a3462ae2..2fdb3a48d 100644
--- a/src/quick/scenegraph/qsgdefaultrendercontext_p.h
+++ b/src/quick/scenegraph/qsgdefaultrendercontext_p.h
@@ -104,6 +104,7 @@ public:
     void initialize(const QSGRenderContext::InitParams *params) override;
     void invalidate() override;
 
+    void prepareSync(qreal devicePixelRatio) override;
     void beginNextFrame(QSGRenderer *renderer,
                         RenderPassCallback mainPassRecordingStart,
                         RenderPassCallback mainPassRecordingEnd,
@@ -151,6 +152,17 @@ public:
         return m_currentFrameRenderPass;
     }
 
+    qreal currentDevicePixelRatio() const
+    {
+        // Valid starting from QQuickWindow::syncSceneGraph(). This takes the
+        // redirections, e.g. QQuickWindow::setRenderTarget(), into account.
+        // This calculation logic matches what the renderer does, so this is
+        // the same value that gets exposed in RenderState::devicePixelRatio()
+        // to material shaders. This getter is useful to perform dpr-related
+        // operations in the sync phase (in updatePaintNode()).
+        return m_currentDevicePixelRatio;
+    }
+
 protected:
     static QString fontKey(const QRawFont &font);
 
@@ -166,6 +178,7 @@ protected:
     QSGRhiAtlasTexture::Manager *m_rhiAtlasManager;
     QRhiCommandBuffer *m_currentFrameCommandBuffer;
     QRhiRenderPassDescriptor *m_currentFrameRenderPass;
+    qreal m_currentDevicePixelRatio;
 };
 
 QT_END_NAMESPACE
diff --git a/src/quick/scenegraph/qsgrenderloop.cpp b/src/quick/scenegraph/qsgrenderloop.cpp
index ba231f815..f60905567 100644
--- a/src/quick/scenegraph/qsgrenderloop.cpp
+++ b/src/quick/scenegraph/qsgrenderloop.cpp
@@ -619,6 +619,24 @@ void QSGGuiThreadRenderLoop::renderWindow(QQuickWindow *window)
         i++;
     }
 
+    // Check for context loss.
+    if (!current && !rhi && !gl->isValid()) {
+        for (auto it = m_windows.constBegin() ; it != m_windows.constEnd(); it++) {
+            QQuickWindowPrivate *windowPrivate = QQuickWindowPrivate::get(it.key());
+            windowPrivate->cleanupNodesOnShutdown();
+        }
+        rc->invalidate();
+        current = gl->create() && gl->makeCurrent(window);
+        if (current) {
+            QSGDefaultRenderContext::InitParams rcParams;
+            rcParams.sampleCount = qMax(1, gl->format().samples());
+            rcParams.openGLContext = gl;
+            rcParams.initialSurfacePixelSize = window->size() * window->effectiveDevicePixelRatio();
+            rcParams.maybeSurface = window;
+            rc->initialize(&rcParams);
+        }
+    }
+
     if (!current)
         return;
 
diff --git a/src/quick/scenegraph/qsgrhidistancefieldglyphcache.cpp b/src/quick/scenegraph/qsgrhidistancefieldglyphcache.cpp
index 28fc10e41..53b6fe117 100644
--- a/src/quick/scenegraph/qsgrhidistancefieldglyphcache.cpp
+++ b/src/quick/scenegraph/qsgrhidistancefieldglyphcache.cpp
@@ -182,7 +182,9 @@ void QSGRhiDistanceFieldGlyphCache::storeGlyphs(const QList<QDistanceField> &gly
     for (int i = 0; i < glyphs.size(); ++i) {
         TextureInfo *texInfo = m_glyphsTexture.value(glyphs.at(i).glyph());
         if (!texInfo->uploads.isEmpty()) {
-            m_resourceUpdates->uploadTexture(texInfo->texture, texInfo->uploads);
+            QRhiTextureUploadDescription desc;
+            desc.setEntries(texInfo->uploads.cbegin(), texInfo->uploads.cend());
+            m_resourceUpdates->uploadTexture(texInfo->texture, desc);
             texInfo->uploads.clear();
         }
     }
diff --git a/src/quick/scenegraph/qsgrhidistancefieldglyphcache_p.h b/src/quick/scenegraph/qsgrhidistancefieldglyphcache_p.h
index ddd3d92ba..d43b0aa5d 100644
--- a/src/quick/scenegraph/qsgrhidistancefieldglyphcache_p.h
+++ b/src/quick/scenegraph/qsgrhidistancefieldglyphcache_p.h
@@ -88,7 +88,7 @@ private:
         QRect allocatedArea;
         QDistanceField image;
         int padding = -1;
-        QVector<QRhiTextureUploadEntry> uploads;
+        QVarLengthArray<QRhiTextureUploadEntry, 16> uploads;
 
         TextureInfo(const QRect &preallocRect = QRect()) : texture(nullptr), allocatedArea(preallocRect) { }
     };
diff --git a/src/quick/scenegraph/qsgrhitextureglyphcache.cpp b/src/quick/scenegraph/qsgrhitextureglyphcache.cpp
index 99761302e..d0108bc56 100644
--- a/src/quick/scenegraph/qsgrhitextureglyphcache.cpp
+++ b/src/quick/scenegraph/qsgrhitextureglyphcache.cpp
@@ -223,7 +223,9 @@ void QSGRhiTextureGlyphCache::endFillTexture()
     if (!m_resourceUpdates)
         m_resourceUpdates = m_rhi->nextResourceUpdateBatch();
 
-    m_resourceUpdates->uploadTexture(m_texture, m_uploads);
+    QRhiTextureUploadDescription desc;
+    desc.setEntries(m_uploads.cbegin(), m_uploads.cend());
+    m_resourceUpdates->uploadTexture(m_texture, desc);
     m_uploads.clear();
 }
 
diff --git a/src/quick/scenegraph/qsgrhitextureglyphcache_p.h b/src/quick/scenegraph/qsgrhitextureglyphcache_p.h
index 75d82de90..a7374d91a 100644
--- a/src/quick/scenegraph/qsgrhitextureglyphcache_p.h
+++ b/src/quick/scenegraph/qsgrhitextureglyphcache_p.h
@@ -90,7 +90,7 @@ private:
     QRhiTexture *m_texture = nullptr;
     QSize m_size;
     bool m_bgra = false;
-    QVector<QRhiTextureUploadEntry> m_uploads;
+    QVarLengthArray<QRhiTextureUploadEntry, 16> m_uploads;
     QSet<QRhiTexture *> m_pendingDispose;
 };
 
diff --git a/src/quick/scenegraph/qsgthreadedrenderloop.cpp b/src/quick/scenegraph/qsgthreadedrenderloop.cpp
index 86d959086..dc1f97de5 100644
--- a/src/quick/scenegraph/qsgthreadedrenderloop.cpp
+++ b/src/quick/scenegraph/qsgthreadedrenderloop.cpp
@@ -807,9 +807,7 @@ void QSGRenderThread::syncAndRender(QImage *grabImage)
         }
     }
     if (current) {
-        const QSize outputSize = rhi ? cd->swapchain->currentPixelSize() : windowSize;
-
-        d->renderSceneGraph(outputSize);
+        d->renderSceneGraph(windowSize, rhi ? cd->swapchain->currentPixelSize() : QSize());
 
         if (profileFrames)
             renderTime = threadTimer.nsecsElapsed();
diff --git a/src/quick/scenegraph/util/qsgopenglatlastexture.cpp b/src/quick/scenegraph/util/qsgopenglatlastexture.cpp
index ae7d9cf8c..75a874424 100644
--- a/src/quick/scenegraph/util/qsgopenglatlastexture.cpp
+++ b/src/quick/scenegraph/util/qsgopenglatlastexture.cpp
@@ -150,6 +150,10 @@ QSGTexture *Manager::create(const QSGCompressedTextureFactory *factory)
     case QOpenGLTexture::RGB8_ETC2:
     case QOpenGLTexture::RGBA8_ETC2_EAC:
     case QOpenGLTexture::RGB8_PunchThrough_Alpha1_ETC2:
+    case QOpenGLTexture::RGB_DXT1:
+    case QOpenGLTexture::RGBA_DXT1:
+    case QOpenGLTexture::RGBA_DXT3:
+    case QOpenGLTexture::RGBA_DXT5:
         break;
     default:
         return t;
@@ -158,8 +162,12 @@ QSGTexture *Manager::create(const QSGCompressedTextureFactory *factory)
     QSize size = factory->m_textureData.size();
     if (size.width() < m_atlas_size_limit && size.height() < m_atlas_size_limit) {
         QHash<unsigned int, QSGCompressedAtlasTexture::Atlas*>::iterator i = m_atlases.find(format);
-        if (i == m_atlases.end())
-            i = m_atlases.insert(format, new QSGCompressedAtlasTexture::Atlas(m_atlas_size, format));
+        if (i == m_atlases.end()) {
+            // must be multiple of 4
+            QSize paddedSize(((m_atlas_size.width() + 3) / 4) * 4, ((m_atlas_size.height() + 3) / 4) * 4);
+            i = m_atlases.insert(format, new QSGCompressedAtlasTexture::Atlas(paddedSize, format));
+        }
+
         // must be multiple of 4
         QSize paddedSize(((size.width() + 3) / 4) * 4, ((size.height() + 3) / 4) * 4);
         QByteArray data = factory->m_textureData.data();
diff --git a/src/quick/scenegraph/util/qsgrhiatlastexture.cpp b/src/quick/scenegraph/util/qsgrhiatlastexture.cpp
index 665e9bb41..3dc1f5f52 100644
--- a/src/quick/scenegraph/util/qsgrhiatlastexture.cpp
+++ b/src/quick/scenegraph/util/qsgrhiatlastexture.cpp
@@ -295,8 +295,7 @@ void Atlas::enqueueTextureUpload(TextureBase *t, QRhiResourceUpdateBatch *resour
     const int tmpBitsSize = tmpBits.size() * 4;
     const quint32 *src = reinterpret_cast<const quint32 *>(image.constBits());
     quint32 *dst = tmpBits.data();
-    QVector<QRhiTextureUploadEntry> entries;
-    entries.reserve(5);
+    QVarLengthArray<QRhiTextureUploadEntry, 5> entries;
 
     // top row, padding corners
     dst[0] = src[0];
@@ -361,7 +360,9 @@ void Atlas::enqueueTextureUpload(TextureBase *t, QRhiResourceUpdateBatch *resour
         entries.append(QRhiTextureUploadEntry(0, 0, subresDesc));
     }
 
-    resourceUpdates->uploadTexture(m_texture, QRhiTextureUploadDescription(entries));
+    QRhiTextureUploadDescription desc;
+    desc.setEntries(entries.cbegin(), entries.cend());
+    resourceUpdates->uploadTexture(m_texture, desc);
 
     const QSize textureSize = t->textureSize();
     if (textureSize.width() > m_atlas_transient_image_threshold || textureSize.height() > m_atlas_transient_image_threshold)
diff --git a/src/quick/util/qquickanimation.cpp b/src/quick/util/qquickanimation.cpp
index 2043b5054..fe5b372da 100644
--- a/src/quick/util/qquickanimation.cpp
+++ b/src/quick/util/qquickanimation.cpp
@@ -2636,7 +2636,7 @@ QQuickStateActions QQuickPropertyAnimation::createTransitionActions(QQuickStateA
             for (int j = 0; j < targets.count(); ++j) {
                 QQuickStateAction myAction;
                 QString errorMessage;
-                const QString propertyName = props.at(i);
+                const QString &propertyName = props.at(i);
                 myAction.property = d->createProperty(targets.at(j), propertyName, this, &errorMessage);
                 if (myAction.property.isValid()) {
                     if (usingDefaultProperties)
diff --git a/src/quick/util/qquickshortcut.cpp b/src/quick/util/qquickshortcut.cpp
index 730a14369..5d227b461 100644
--- a/src/quick/util/qquickshortcut.cpp
+++ b/src/quick/util/qquickshortcut.cpp
@@ -216,7 +216,7 @@ void QQuickShortcut::setSequences(const QVariantList &values)
 
     bool changed = !remainder.isEmpty();
     for (int i = 0; i < values.count(); ++i) {
-        QVariant value = values.at(i);
+        const QVariant &value = values.at(i);
         Shortcut& shortcut = m_shortcuts[i];
         if (value == shortcut.userValue)
             continue;
diff --git a/src/quick/util/qquickstategroup.cpp b/src/quick/util/qquickstategroup.cpp
index 0adae82dc..46e7d62fc 100644
--- a/src/quick/util/qquickstategroup.cpp
+++ b/src/quick/util/qquickstategroup.cpp
@@ -311,7 +311,7 @@ void QQuickStateGroup::componentComplete()
         if (!state->isNamed())
             state->setName(QLatin1String("anonymousState") + QString::number(++d->unnamedCount));
 
-        const QString stateName = state->name();
+        QString stateName = state->name();
         if (names.contains(stateName)) {
             qmlWarning(state->parent()) << "Found duplicate state name: " << stateName;
         } else {
diff --git a/src/quick/util/qquickvaluetypes.cpp b/src/quick/util/qquickvaluetypes.cpp
index e4a03f3b5..0af29aed1 100644
--- a/src/quick/util/qquickvaluetypes.cpp
+++ b/src/quick/util/qquickvaluetypes.cpp
@@ -109,6 +109,11 @@ qreal QQuickColorValueType::hslLightness() const
     return v.lightnessF();
 }
 
+bool QQuickColorValueType::isValid() const
+{
+    return v.isValid();
+}
+
 void QQuickColorValueType::setR(qreal r)
 {
     v.setRedF(r);
diff --git a/src/quick/util/qquickvaluetypes_p.h b/src/quick/util/qquickvaluetypes_p.h
index 5a9af970e..4305006f9 100644
--- a/src/quick/util/qquickvaluetypes_p.h
+++ b/src/quick/util/qquickvaluetypes_p.h
@@ -84,6 +84,7 @@ class QQuickColorValueType
     Q_PROPERTY(qreal hslHue READ hslHue WRITE setHslHue FINAL)
     Q_PROPERTY(qreal hslSaturation READ hslSaturation WRITE setHslSaturation FINAL)
     Q_PROPERTY(qreal hslLightness READ hslLightness WRITE setHslLightness FINAL)
+    Q_PROPERTY(bool valid READ isValid)
     Q_GADGET
 public:
     Q_INVOKABLE QString toString() const;
@@ -98,6 +99,7 @@ public:
     qreal hslHue() const;
     qreal hslSaturation() const;
     qreal hslLightness() const;
+    bool isValid() const;
     void setR(qreal);
     void setG(qreal);
     void setB(qreal);
diff --git a/src/quickshapes/qquickshapenvprrenderer.cpp b/src/quickshapes/qquickshapenvprrenderer.cpp
index a5b2a3467..721091b66 100644
--- a/src/quickshapes/qquickshapenvprrenderer.cpp
+++ b/src/quickshapes/qquickshapenvprrenderer.cpp
@@ -177,7 +177,7 @@ QDebug operator<<(QDebug debug, const QQuickShapeNvprRenderer::NvprPath &path)
     debug << "Path with" << path.cmd.count() << "commands";
     int ci = 0;
     for (GLubyte cmd : path.cmd) {
-        static struct { GLubyte cmd; const char *s; int coordCount; } nameTab[] = {
+        static struct { GLubyte cmd; const char *s; int coordCount; } nameTabs[] = {
         { GL_MOVE_TO_NV, "moveTo", 2 },
         { GL_LINE_TO_NV, "lineTo", 2 },
         { GL_QUADRATIC_CURVE_TO_NV, "quadTo", 4 },
@@ -187,14 +187,14 @@ QDebug operator<<(QDebug debug, const QQuickShapeNvprRenderer::NvprPath &path)
         { GL_SMALL_CW_ARC_TO_NV, "arcTo-small-CW", 5 },
         { GL_SMALL_CCW_ARC_TO_NV, "arcTo-small-CCW", 5 },
         { GL_CLOSE_PATH_NV, "closePath", 0 } };
-        for (size_t i = 0; i < sizeof(nameTab) / sizeof(nameTab[0]); ++i) {
-            if (nameTab[i].cmd == cmd) {
+        for (const auto &nameTab : nameTabs) {
+            if (nameTab.cmd == cmd) {
                 QByteArray cs;
-                for (int j = 0; j < nameTab[i].coordCount; ++j) {
+                for (int j = 0; j < nameTab.coordCount; ++j) {
                     cs.append(QByteArray::number(path.coord[ci++]));
                     cs.append(' ');
                 }
-                debug << "\n  " << nameTab[i].s << " " << cs;
+                debug << "\n  " << nameTab.s << " " << cs;
                 break;
             }
         }
diff --git a/src/quickwidgets/qquickwidget.cpp b/src/quickwidgets/qquickwidget.cpp
index 0da9b12e8..c975404d6 100644
--- a/src/quickwidgets/qquickwidget.cpp
+++ b/src/quickwidgets/qquickwidget.cpp
@@ -283,7 +283,16 @@ void QQuickWidgetPrivate::render(bool needsSync)
 
         Q_ASSERT(context);
 
-        if (!context->makeCurrent(offscreenSurface)) {
+        bool current = context->makeCurrent(offscreenSurface);
+
+        if (!current && !context->isValid()) {
+            renderControl->invalidate();
+            current = context->create() && context->makeCurrent(offscreenSurface);
+            if (current)
+                renderControl->initialize(context);
+        }
+
+        if (!current) {
             qWarning("QQuickWidget: Cannot render due to failing makeCurrent()");
             return;
         }
diff --git a/tests/auto/qml/qjsengine/tst_qjsengine.cpp b/tests/auto/qml/qjsengine/tst_qjsengine.cpp
index 1c895eb79..f1ff396d4 100644
--- a/tests/auto/qml/qjsengine/tst_qjsengine.cpp
+++ b/tests/auto/qml/qjsengine/tst_qjsengine.cpp
@@ -4888,6 +4888,7 @@ void tst_QJSEngine::interrupt_data()
         QTest::addRow("labeled continue / %s", mode)   << i << "a: while (true) { for (;;) { continue a; } }";
         QTest::addRow("labeled break / %s", mode)      << i << "while (true) { a: for (;;) { break a; } }";
         QTest::addRow("tail call / %s", mode)          << i << "'use strict';\nfunction x() { return x(); }; x();";
+        QTest::addRow("huge array join / %s", mode)    << i << "Array(1E9)|1";
     }
 }
 
diff --git a/tests/auto/qml/qmlcachegen/data/parameterAdjustment.qml b/tests/auto/qml/qmlcachegen/data/parameterAdjustment.qml
new file mode 100644
index 000000000..2128a54d8
--- /dev/null
+++ b/tests/auto/qml/qmlcachegen/data/parameterAdjustment.qml
@@ -0,0 +1,7 @@
+import QtQml 2.12
+
+QtObject {
+    signal testSignal(string a, int b, string c, bool d, bool e, real f, real g, bool h, int i, int j, string k, int l, string m, string n)
+    onTestSignal: {}
+    Component.onCompleted: testSignal("a", 1, "b", true, true, 0.1, 0.1, true, 1, 1, "a", 1, "a", "a")
+}
diff --git a/tests/auto/qml/qmlcachegen/qmlcachegen.pro b/tests/auto/qml/qmlcachegen/qmlcachegen.pro
index 53b26ccfa..4daf1d35c 100644
--- a/tests/auto/qml/qmlcachegen/qmlcachegen.pro
+++ b/tests/auto/qml/qmlcachegen/qmlcachegen.pro
@@ -17,7 +17,8 @@ RESOURCES += \
     data/jsmoduleimport.qml \
     data/script.mjs \
     data/module.mjs \
-    data/utils.mjs
+    data/utils.mjs \
+    data/parameterAdjustment.qml
 
 workerscripts_test.files = \
     data/worker.js \
diff --git a/tests/auto/qml/qmlcachegen/tst_qmlcachegen.cpp b/tests/auto/qml/qmlcachegen/tst_qmlcachegen.cpp
index f89982f78..4a1f5378a 100644
--- a/tests/auto/qml/qmlcachegen/tst_qmlcachegen.cpp
+++ b/tests/auto/qml/qmlcachegen/tst_qmlcachegen.cpp
@@ -73,6 +73,8 @@ private slots:
 
     void reproducibleCache_data();
     void reproducibleCache();
+
+    void parameterAdjustment();
 };
 
 // A wrapper around QQmlComponent to ensure the temporary reference counts
@@ -670,6 +672,14 @@ void tst_qmlcachegen::reproducibleCache()
     QCOMPARE(contents1, contents2);
 }
 
+void tst_qmlcachegen::parameterAdjustment()
+{
+    QQmlEngine engine;
+    CleanlyLoadingComponent component(&engine, QUrl("qrc:///data/parameterAdjustment.qml"));
+    QScopedPointer<QObject> obj(component.create());
+    QVERIFY(!obj.isNull()); // Doesn't crash
+}
+
 QTEST_GUILESS_MAIN(tst_qmlcachegen)
 
 #include "tst_qmlcachegen.moc"
diff --git a/tests/auto/qml/qmlmin/tst_qmlmin.cpp b/tests/auto/qml/qmlmin/tst_qmlmin.cpp
index cae833cd6..e24436958 100644
--- a/tests/auto/qml/qmlmin/tst_qmlmin.cpp
+++ b/tests/auto/qml/qmlmin/tst_qmlmin.cpp
@@ -130,6 +130,7 @@ void tst_qmlmin::initTestCase()
     invalidFiles << "tests/auto/qml/qjsengine/script/com/trolltech/syntaxerror/__init__.js";
     invalidFiles << "tests/auto/qml/debugger/qqmlpreview/data/broken.qml";
     invalidFiles << "tests/auto/qml/qqmllanguage/data/fuzzed.2.qml";
+    invalidFiles << "tests/auto/qml/qqmllanguage/data/fuzzed.3.qml";
     // generatorFunction.qml is not invalid per se, but the minifier cannot handle yield statements
     invalidFiles << "tests/auto/qml/qqmlecmascript/data/generatorFunction.qml";
 #endif
diff --git a/tests/auto/qml/qmlplugindump/data/dumper/Imports/Derived.qml b/tests/auto/qml/qmlplugindump/data/dumper/Imports/Derived.qml
new file mode 100644
index 000000000..2f0ac401d
--- /dev/null
+++ b/tests/auto/qml/qmlplugindump/data/dumper/Imports/Derived.qml
@@ -0,0 +1,6 @@
+pragma Singleton
+import dumper.Imports 1.0
+
+Imports {
+    property int something: 2
+}
diff --git a/tests/auto/qml/qmlplugindump/data/dumper/Imports/imports.pro b/tests/auto/qml/qmlplugindump/data/dumper/Imports/imports.pro
index d20ea967e..b4bd9baf5 100644
--- a/tests/auto/qml/qmlplugindump/data/dumper/Imports/imports.pro
+++ b/tests/auto/qml/qmlplugindump/data/dumper/Imports/imports.pro
@@ -17,7 +17,7 @@ HEADERS += \
     imports.h
 
 !equals(_PRO_FILE_PWD_, $$OUT_PWD) {
-    cp.files = qmldir plugins.qmltypes CompositeImports.qml
+    cp.files = qmldir plugins.qmltypes CompositeImports.qml Derived.qml
     cp.path = $$OUT_PWD
     COPIES += cp
 }
diff --git a/tests/auto/qml/qmlplugindump/data/dumper/Imports/plugins.qmltypes b/tests/auto/qml/qmlplugindump/data/dumper/Imports/plugins.qmltypes
index 937dd60a9..fb13928ba 100644
--- a/tests/auto/qml/qmlplugindump/data/dumper/Imports/plugins.qmltypes
+++ b/tests/auto/qml/qmlplugindump/data/dumper/Imports/plugins.qmltypes
@@ -14,4 +14,14 @@ Module {
         exports: ["dumper.Imports/Imports 1.0"]
         exportMetaObjectRevisions: [0]
     }
+    Component {
+        prototype: "Imports"
+        name: "dumper.Imports/Derived 1.0"
+        exports: ["dumper.Imports/Derived 1.0"]
+        exportMetaObjectRevisions: [0]
+        isComposite: true
+        isCreatable: false
+        isSingleton: true
+        Property { name: "something"; type: "int" }
+    }
 }
diff --git a/tests/auto/qml/qmlplugindump/data/dumper/Imports/qmldir b/tests/auto/qml/qmlplugindump/data/dumper/Imports/qmldir
index c9058a7f9..f84fca1d7 100644
--- a/tests/auto/qml/qmlplugindump/data/dumper/Imports/qmldir
+++ b/tests/auto/qml/qmlplugindump/data/dumper/Imports/qmldir
@@ -1,3 +1,4 @@
 module dumper.Imports
 plugin Imports
 CompositeImports 1.0 CompositeImports.qml
+singleton Derived 1.0 Derived.qml
diff --git a/tests/auto/qml/qqmlbinding/data/nanPropertyToInt.qml b/tests/auto/qml/qqmlbinding/data/nanPropertyToInt.qml
new file mode 100644
index 000000000..366dbf046
--- /dev/null
+++ b/tests/auto/qml/qqmlbinding/data/nanPropertyToInt.qml
@@ -0,0 +1,14 @@
+import QtQuick 2.11
+
+Item {
+    visible: true
+    width: 320
+    height: 200
+    property int val: other.val
+
+    Rectangle {
+        id: other
+        anchors.fill: parent;
+        property int val: undefined / 2
+    }
+}
diff --git a/tests/auto/qml/qqmlbinding/data/noUnexpectedStringConversion.qml b/tests/auto/qml/qqmlbinding/data/noUnexpectedStringConversion.qml
new file mode 100644
index 000000000..d0f30c5da
--- /dev/null
+++ b/tests/auto/qml/qqmlbinding/data/noUnexpectedStringConversion.qml
@@ -0,0 +1,30 @@
+import QtQuick 2.12
+import QtQuick.Window 2.12
+
+Window {
+visible: true
+width: 640
+height: 480
+title: qsTr("Hello World")
+
+    Rectangle {
+        id: colorRect
+        objectName: "colorRect"
+        anchors.fill: parent
+        Text {
+            objectName: "colorLabel"
+            id: colorLabel
+        }
+    }
+
+    Binding {
+        target: colorLabel
+        property: "text"
+        value: "red"
+    }
+    Binding {
+        target: colorRect
+        property: "color"
+        value: "red"
+    }
+}
diff --git a/tests/auto/qml/qqmlbinding/tst_qqmlbinding.cpp b/tests/auto/qml/qqmlbinding/tst_qqmlbinding.cpp
index 9b66cd828..261040245 100644
--- a/tests/auto/qml/qqmlbinding/tst_qqmlbinding.cpp
+++ b/tests/auto/qml/qqmlbinding/tst_qqmlbinding.cpp
@@ -55,6 +55,8 @@ private slots:
     void delayed();
     void bindingOverwriting();
     void bindToQmlComponent();
+    void bindingDoesNoWeirdConversion();
+    void bindNaNToInt();
 
 private:
     QQmlEngine engine;
@@ -68,7 +70,7 @@ void tst_qqmlbinding::binding()
 {
     QQmlEngine engine;
     QQmlComponent c(&engine, testFileUrl("test-binding.qml"));
-    QQuickRectangle *rect = qobject_cast<QQuickRectangle*>(c.create());
+    QScopedPointer<QQuickRectangle> rect { qobject_cast<QQuickRectangle*>(c.create()) };
     QVERIFY(rect != nullptr);
 
     QQmlBind *binding3 = qobject_cast<QQmlBind*>(rect->findChild<QQmlBind*>("binding3"));
@@ -85,18 +87,16 @@ void tst_qqmlbinding::binding()
 
     QQmlBind *binding = qobject_cast<QQmlBind*>(rect->findChild<QQmlBind*>("binding1"));
     QVERIFY(binding != nullptr);
-    QCOMPARE(binding->object(), qobject_cast<QObject*>(rect));
+    QCOMPARE(binding->object(), qobject_cast<QObject*>(rect.get()));
     QCOMPARE(binding->property(), QLatin1String("text"));
     QCOMPARE(binding->value().toString(), QLatin1String("Hello"));
-
-    delete rect;
 }
 
 void tst_qqmlbinding::whenAfterValue()
 {
     QQmlEngine engine;
     QQmlComponent c(&engine, testFileUrl("test-binding2.qml"));
-    QQuickRectangle *rect = qobject_cast<QQuickRectangle*>(c.create());
+    QScopedPointer<QQuickRectangle> rect {qobject_cast<QQuickRectangle*>(c.create())};
 
     QVERIFY(rect != nullptr);
     QCOMPARE(rect->color(), QColor("yellow"));
@@ -104,15 +104,13 @@ void tst_qqmlbinding::whenAfterValue()
 
     rect->setProperty("changeColor", true);
     QCOMPARE(rect->color(), QColor("red"));
-
-    delete rect;
 }
 
 void tst_qqmlbinding::restoreBinding()
 {
     QQmlEngine engine;
     QQmlComponent c(&engine, testFileUrl("restoreBinding.qml"));
-    QQuickRectangle *rect = qobject_cast<QQuickRectangle*>(c.create());
+    QScopedPointer<QQuickRectangle> rect { qobject_cast<QQuickRectangle*>(c.create()) };
     QVERIFY(rect != nullptr);
 
     QQuickRectangle *myItem = qobject_cast<QQuickRectangle*>(rect->findChild<QQuickRectangle*>("myItem"));
@@ -134,8 +132,6 @@ void tst_qqmlbinding::restoreBinding()
     //original binding restored
     myItem->setY(49);
     QCOMPARE(myItem->x(), qreal(100-49));
-
-    delete rect;
 }
 
 void tst_qqmlbinding::restoreBindingValue()
@@ -214,7 +210,7 @@ void tst_qqmlbinding::restoreBindingWithLoop()
 {
     QQmlEngine engine;
     QQmlComponent c(&engine, testFileUrl("restoreBindingWithLoop.qml"));
-    QQuickRectangle *rect = qobject_cast<QQuickRectangle*>(c.create());
+    QScopedPointer<QQuickRectangle> rect {qobject_cast<QQuickRectangle*>(c.create())};
     QVERIFY(rect != nullptr);
 
     QQuickRectangle *myItem = qobject_cast<QQuickRectangle*>(rect->findChild<QQuickRectangle*>("myItem"));
@@ -242,15 +238,13 @@ void tst_qqmlbinding::restoreBindingWithLoop()
 
     myItem->setY(49);
     QCOMPARE(myItem->x(), qreal(49 + 100));
-
-    delete rect;
 }
 
 void tst_qqmlbinding::restoreBindingWithoutCrash()
 {
     QQmlEngine engine;
     QQmlComponent c(&engine, testFileUrl("restoreBindingWithoutCrash.qml"));
-    QQuickRectangle *rect = qobject_cast<QQuickRectangle*>(c.create());
+    QScopedPointer<QQuickRectangle> rect {qobject_cast<QQuickRectangle*>(c.create())};
     QVERIFY(rect != nullptr);
 
     QQuickRectangle *myItem = qobject_cast<QQuickRectangle*>(rect->findChild<QQuickRectangle*>("myItem"));
@@ -281,8 +275,6 @@ void tst_qqmlbinding::restoreBindingWithoutCrash()
     //original binding restored
     myItem->setY(49);
     QCOMPARE(myItem->x(), qreal(100-49));
-
-    delete rect;
 }
 
 //QTBUG-20692
@@ -290,15 +282,13 @@ void tst_qqmlbinding::deletedObject()
 {
     QQmlEngine engine;
     QQmlComponent c(&engine, testFileUrl("deletedObject.qml"));
-    QQuickRectangle *rect = qobject_cast<QQuickRectangle*>(c.create());
+    QScopedPointer<QQuickRectangle> rect {qobject_cast<QQuickRectangle*>(c.create())};
     QVERIFY(rect != nullptr);
 
     QGuiApplication::sendPostedEvents(nullptr, QEvent::DeferredDelete);
 
     //don't crash
     rect->setProperty("activateBinding", true);
-
-    delete rect;
 }
 
 void tst_qqmlbinding::warningOnUnknownProperty()
@@ -307,9 +297,8 @@ void tst_qqmlbinding::warningOnUnknownProperty()
 
     QQmlEngine engine;
     QQmlComponent c(&engine, testFileUrl("unknownProperty.qml"));
-    QQuickItem *item = qobject_cast<QQuickItem*>(c.create());
+    QScopedPointer<QQuickItem> item { qobject_cast<QQuickItem *>(c.create()) };
     QVERIFY(item);
-    delete item;
 
     QCOMPARE(messageHandler.messages().count(), 1);
 
@@ -323,9 +312,8 @@ void tst_qqmlbinding::warningOnReadOnlyProperty()
 
     QQmlEngine engine;
     QQmlComponent c(&engine, testFileUrl("readonlyProperty.qml"));
-    QQuickItem *item = qobject_cast<QQuickItem*>(c.create());
+    QScopedPointer<QQuickItem> item { qobject_cast<QQuickItem *>(c.create()) };
     QVERIFY(item);
-    delete item;
 
     QCOMPARE(messageHandler.messages().count(), 1);
 
@@ -339,9 +327,8 @@ void tst_qqmlbinding::disabledOnUnknownProperty()
 
     QQmlEngine engine;
     QQmlComponent c(&engine, testFileUrl("disabledUnknown.qml"));
-    QQuickItem *item = qobject_cast<QQuickItem*>(c.create());
+    QScopedPointer<QQuickItem> item { qobject_cast<QQuickItem *>(c.create()) };
     QVERIFY(item);
-    delete item;
 
     QCOMPARE(messageHandler.messages().count(), 0);
 }
@@ -352,10 +339,8 @@ void tst_qqmlbinding::disabledOnReadonlyProperty()
 
     QQmlEngine engine;
     QQmlComponent c(&engine, testFileUrl("disabledReadonly.qml"));
-    QQuickItem *item = qobject_cast<QQuickItem*>(c.create());
+    QScopedPointer<QQuickItem> item { qobject_cast<QQuickItem *>(c.create()) };
     QVERIFY(item);
-    delete item;
-
     QCOMPARE(messageHandler.messages().count(), 0);
 }
 
@@ -363,21 +348,19 @@ void tst_qqmlbinding::delayed()
 {
     QQmlEngine engine;
     QQmlComponent c(&engine, testFileUrl("delayed.qml"));
-    QQuickItem *item = qobject_cast<QQuickItem*>(c.create());
+    QScopedPointer<QQuickItem> item {qobject_cast<QQuickItem*>(c.create())};
 
     QVERIFY(item != nullptr);
     // update on creation
     QCOMPARE(item->property("changeCount").toInt(), 1);
 
-    QMetaObject::invokeMethod(item, "updateText");
+    QMetaObject::invokeMethod(item.get(), "updateText");
     // doesn't update immediately
     QCOMPARE(item->property("changeCount").toInt(), 1);
 
     QCoreApplication::processEvents();
     // only updates once (non-delayed would update twice)
     QCOMPARE(item->property("changeCount").toInt(), 2);
-
-    delete item;
 }
 
 void tst_qqmlbinding::bindingOverwriting()
@@ -387,9 +370,8 @@ void tst_qqmlbinding::bindingOverwriting()
 
     QQmlEngine engine;
     QQmlComponent c(&engine, testFileUrl("bindingOverwriting.qml"));
-    QQuickItem *item = qobject_cast<QQuickItem*>(c.create());
+    QScopedPointer<QQuickItem> item {qobject_cast<QQuickItem*>(c.create())};
     QVERIFY(item);
-    delete item;
 
     QLoggingCategory::setFilterRules(QString());
     QCOMPARE(messageHandler.messages().count(), 2);
@@ -402,6 +384,31 @@ void tst_qqmlbinding::bindToQmlComponent()
     QVERIFY(c.create());
 }
 
+// QTBUG-78943
+void tst_qqmlbinding::bindingDoesNoWeirdConversion()
+{
+    QQmlEngine engine;
+    QQmlComponent c(&engine, testFileUrl("noUnexpectedStringConversion.qml"));
+    QScopedPointer<QObject> o {c.create()};
+    QVERIFY(o);
+    QObject *colorRect = o->findChild<QObject*>("colorRect");
+    QVERIFY(colorRect);
+    QCOMPARE(qvariant_cast<QColor>(colorRect->property("color")), QColorConstants::Red);
+    QObject *colorLabel = o->findChild<QObject*>("colorLabel");
+    QCOMPARE(colorLabel->property("text").toString(), QLatin1String("red"));
+    QVERIFY(colorLabel);
+}
+
+//QTBUG-72442
+void tst_qqmlbinding::bindNaNToInt()
+{
+    QQmlEngine engine;
+    QQmlComponent c(&engine, testFileUrl("nanPropertyToInt.qml"));
+    QScopedPointer<QQuickItem> item(qobject_cast<QQuickItem*>(c.create()));
+
+    QVERIFY(item != nullptr);
+    QCOMPARE(item->property("val").toInt(), 0);
+}
 QTEST_MAIN(tst_qqmlbinding)
 
 #include "tst_qqmlbinding.moc"
diff --git a/tests/auto/qml/qqmlcontext/tst_qqmlcontext.cpp b/tests/auto/qml/qqmlcontext/tst_qqmlcontext.cpp
index d9cb6673d..6754f2204 100644
--- a/tests/auto/qml/qqmlcontext/tst_qqmlcontext.cpp
+++ b/tests/auto/qml/qqmlcontext/tst_qqmlcontext.cpp
@@ -895,16 +895,27 @@ void tst_qqmlcontext::contextObjectHierarchy()
 
 void tst_qqmlcontext::destroyContextProperty()
 {
-    QQmlEngine engine;
-    QQmlContext context(&engine);
-
+    QScopedPointer<QQmlContext> context;
+    QScopedPointer<QObject> objectThatOutlivesEngine(new QObject);
     {
-        QObject object;
-        context.setContextProperty(QLatin1String("a"), &object);
-        QCOMPARE(qvariant_cast<QObject *>(context.contextProperty(QLatin1String("a"))), &object);
+        QQmlEngine engine;
+        context.reset(new QQmlContext(&engine));
+
+        {
+            QObject object;
+            context->setContextProperty(QLatin1String("a"), &object);
+            QCOMPARE(qvariant_cast<QObject *>(context->contextProperty(QLatin1String("a"))), &object);
+        }
+
+        QCOMPARE(qvariant_cast<QObject *>(context->contextProperty(QLatin1String("a"))), nullptr);
+        context->setContextProperty(QLatin1String("b"), objectThatOutlivesEngine.data());
     }
 
-    QCOMPARE(qvariant_cast<QObject *>(context.contextProperty(QLatin1String("a"))), nullptr);
+    // dropDestroyedObject() should not crash, even if the engine is gone.
+    objectThatOutlivesEngine.reset();
+
+    // We're not allowed to call context->contextProperty("b") anymore.
+    // TODO: Or are we?
 }
 
 QTEST_MAIN(tst_qqmlcontext)
diff --git a/tests/auto/qml/qqmlecmascript/data/checkDate-October.qml b/tests/auto/qml/qqmlecmascript/data/checkDate-October.qml
new file mode 100644
index 000000000..6686831e1
--- /dev/null
+++ b/tests/auto/qml/qqmlecmascript/data/checkDate-October.qml
@@ -0,0 +1,12 @@
+import Qt.test 1.0
+import QtQuick 2.0
+
+MyTypeObject {
+    Component.onCompleted: {
+        // QTBUG-78996
+        dateProperty = new Date(2019, 9, 3)
+        boolProperty = (dateProperty.getFullYear() == 2019
+                        && dateProperty.getMonth() == 9
+                        && dateProperty.getDate() == 3)
+    }
+}
diff --git a/tests/auto/qml/qqmlecmascript/data/checkDate-denormal-Feb.qml b/tests/auto/qml/qqmlecmascript/data/checkDate-denormal-Feb.qml
new file mode 100644
index 000000000..29ec40ffb
--- /dev/null
+++ b/tests/auto/qml/qqmlecmascript/data/checkDate-denormal-Feb.qml
@@ -0,0 +1,11 @@
+import Qt.test 1.0
+import QtQuick 2.0
+
+MyTypeObject {
+    Component.onCompleted: {
+        dateProperty = new Date(2019, 2, 0) // Feb 28th
+        boolProperty = (dateProperty.getFullYear() == 2019
+                        && dateProperty.getMonth() == 1
+                        && dateProperty.getDate() == 28)
+    }
+}
diff --git a/tests/auto/qml/qqmlecmascript/data/checkDate-denormal-March.qml b/tests/auto/qml/qqmlecmascript/data/checkDate-denormal-March.qml
new file mode 100644
index 000000000..7fc8bf43b
--- /dev/null
+++ b/tests/auto/qml/qqmlecmascript/data/checkDate-denormal-March.qml
@@ -0,0 +1,11 @@
+import Qt.test 1.0
+import QtQuick 2.0
+
+MyTypeObject {
+    Component.onCompleted: {
+        dateProperty = new Date(2019, 1, 29) // March 1st
+        boolProperty = (dateProperty.getFullYear() == 2019
+                        && dateProperty.getMonth() == 2
+                        && dateProperty.getDate() == 1)
+    }
+}
diff --git a/tests/auto/qml/qqmlecmascript/data/checkDate-denormal-leap.qml b/tests/auto/qml/qqmlecmascript/data/checkDate-denormal-leap.qml
new file mode 100644
index 000000000..6dd84810e
--- /dev/null
+++ b/tests/auto/qml/qqmlecmascript/data/checkDate-denormal-leap.qml
@@ -0,0 +1,11 @@
+import Qt.test 1.0
+import QtQuick 2.0
+
+MyTypeObject {
+    Component.onCompleted: {
+        dateProperty = new Date(2020, 2, 0) // Feb 29th
+        boolProperty = (dateProperty.getFullYear() == 2020
+                        && dateProperty.getMonth() == 1
+                        && dateProperty.getDate() == 29)
+    }
+}
diff --git a/tests/auto/qml/qqmlecmascript/data/checkDate-denormal-wrap.qml b/tests/auto/qml/qqmlecmascript/data/checkDate-denormal-wrap.qml
new file mode 100644
index 000000000..ddb79727e
--- /dev/null
+++ b/tests/auto/qml/qqmlecmascript/data/checkDate-denormal-wrap.qml
@@ -0,0 +1,11 @@
+import Qt.test 1.0
+import QtQuick 2.0
+
+MyTypeObject {
+    Component.onCompleted: {
+        dateProperty = new Date(2017, 40, -61) // 2020, Feb 29th
+        boolProperty = (dateProperty.getFullYear() == 2020
+                        && dateProperty.getMonth() == 1
+                        && dateProperty.getDate() == 29)
+    }
+}
diff --git a/tests/auto/qml/qqmlecmascript/data/checkDate-denormal-year.qml b/tests/auto/qml/qqmlecmascript/data/checkDate-denormal-year.qml
new file mode 100644
index 000000000..90514c39c
--- /dev/null
+++ b/tests/auto/qml/qqmlecmascript/data/checkDate-denormal-year.qml
@@ -0,0 +1,11 @@
+import Qt.test 1.0
+import QtQuick 2.0
+
+MyTypeObject {
+    Component.onCompleted: {
+        dateProperty = new Date(2019, 12, 0) // Dec 31
+        boolProperty = (dateProperty.getFullYear() == 2019
+                        && dateProperty.getMonth() == 11
+                        && dateProperty.getDate() == 31)
+    }
+}
diff --git a/tests/auto/qml/qqmlecmascript/data/checkDateTime-October.qml b/tests/auto/qml/qqmlecmascript/data/checkDateTime-October.qml
new file mode 100644
index 000000000..c97076f88
--- /dev/null
+++ b/tests/auto/qml/qqmlecmascript/data/checkDateTime-October.qml
@@ -0,0 +1,16 @@
+import Qt.test 1.0
+import QtQuick 2.0
+
+MyTypeObject {
+    Component.onCompleted: {
+        // QTBUG-78996
+        dateTimeProperty = new Date(2019, 9, 3, 12)
+        boolProperty = (dateTimeProperty.getFullYear() == 2019
+                        && dateTimeProperty.getMonth() == 9
+                        && dateTimeProperty.getDate() == 3
+                        && dateTimeProperty.getHours() == 12
+                        && dateTimeProperty.getMinutes() == 0
+                        && dateTimeProperty.getSeconds() == 0
+                        && dateTimeProperty.getMilliseconds() == 0)
+    }
+}
diff --git a/tests/auto/qml/qqmlecmascript/data/checkDateTime-denormal-March.qml b/tests/auto/qml/qqmlecmascript/data/checkDateTime-denormal-March.qml
new file mode 100644
index 000000000..2b6b9af3e
--- /dev/null
+++ b/tests/auto/qml/qqmlecmascript/data/checkDateTime-denormal-March.qml
@@ -0,0 +1,15 @@
+import Qt.test 1.0
+import QtQuick 2.0
+
+MyTypeObject {
+    Component.onCompleted: {
+        dateTimeProperty = new Date(2019, 1, 28, 23, 59, 59, 1001) // 2019-3-1 0:0:0.001
+        boolProperty = (dateTimeProperty.getFullYear() == 2019
+                        && dateTimeProperty.getMonth() == 2
+                        && dateTimeProperty.getDate() == 1
+                        && dateTimeProperty.getHours() == 0
+                        && dateTimeProperty.getMinutes() == 0
+                        && dateTimeProperty.getSeconds() == 0
+                        && dateTimeProperty.getMilliseconds() == 1)
+    }
+}
diff --git a/tests/auto/qml/qqmlecmascript/data/checkDateTime-denormal-hours.qml b/tests/auto/qml/qqmlecmascript/data/checkDateTime-denormal-hours.qml
new file mode 100644
index 000000000..7d018e290
--- /dev/null
+++ b/tests/auto/qml/qqmlecmascript/data/checkDateTime-denormal-hours.qml
@@ -0,0 +1,15 @@
+import Qt.test 1.0
+import QtQuick 2.0
+
+MyTypeObject {
+    Component.onCompleted: {
+        dateTimeProperty = new Date(2019, 11, 31, 1440) // 2020-2-29 0:0:0
+        boolProperty = (dateTimeProperty.getFullYear() == 2020
+                        && dateTimeProperty.getMonth() == 1
+                        && dateTimeProperty.getDate() == 29
+                        && dateTimeProperty.getHours() == 0
+                        && dateTimeProperty.getMinutes() == 0
+                        && dateTimeProperty.getSeconds() == 0
+                        && dateTimeProperty.getMilliseconds() == 0)
+    }
+}
diff --git a/tests/auto/qml/qqmlecmascript/data/checkDateTime-denormal-leap.qml b/tests/auto/qml/qqmlecmascript/data/checkDateTime-denormal-leap.qml
new file mode 100644
index 000000000..0a7687c66
--- /dev/null
+++ b/tests/auto/qml/qqmlecmascript/data/checkDateTime-denormal-leap.qml
@@ -0,0 +1,15 @@
+import Qt.test 1.0
+import QtQuick 2.0
+
+MyTypeObject {
+    Component.onCompleted: {
+        dateTimeProperty = new Date(2020, 2, 1, 0, 0, 0, -1) // 2020-2-29 23:59:59.999
+        boolProperty = (dateTimeProperty.getFullYear() == 2020
+                        && dateTimeProperty.getMonth() == 1
+                        && dateTimeProperty.getDate() == 29
+                        && dateTimeProperty.getHours() == 23
+                        && dateTimeProperty.getMinutes() == 59
+                        && dateTimeProperty.getSeconds() == 59
+                        && dateTimeProperty.getMilliseconds() == 999)
+    }
+}
diff --git a/tests/auto/qml/qqmlecmascript/data/checkDateTime-denormal-minutes.qml b/tests/auto/qml/qqmlecmascript/data/checkDateTime-denormal-minutes.qml
new file mode 100644
index 000000000..738d603b4
--- /dev/null
+++ b/tests/auto/qml/qqmlecmascript/data/checkDateTime-denormal-minutes.qml
@@ -0,0 +1,15 @@
+import Qt.test 1.0
+import QtQuick 2.0
+
+MyTypeObject {
+    Component.onCompleted: {
+        dateTimeProperty = new Date(2020, 1, 28, 0, 1440) // 2020-2-29 0:0:0
+        boolProperty = (dateTimeProperty.getFullYear() == 2020
+                        && dateTimeProperty.getMonth() == 1
+                        && dateTimeProperty.getDate() == 29
+                        && dateTimeProperty.getHours() == 0
+                        && dateTimeProperty.getMinutes() == 0
+                        && dateTimeProperty.getSeconds() == 0
+                        && dateTimeProperty.getMilliseconds() == 0)
+    }
+}
diff --git a/tests/auto/qml/qqmlecmascript/data/checkDateTime-denormal-seconds.qml b/tests/auto/qml/qqmlecmascript/data/checkDateTime-denormal-seconds.qml
new file mode 100644
index 000000000..d48534f0d
--- /dev/null
+++ b/tests/auto/qml/qqmlecmascript/data/checkDateTime-denormal-seconds.qml
@@ -0,0 +1,15 @@
+import Qt.test 1.0
+import QtQuick 2.0
+
+MyTypeObject {
+    Component.onCompleted: {
+        dateTimeProperty = new Date(2020, 1, 28, 23, 0, 3600) // 2020-2-29 0:0:0
+        boolProperty = (dateTimeProperty.getFullYear() == 2020
+                        && dateTimeProperty.getMonth() == 1
+                        && dateTimeProperty.getDate() == 29
+                        && dateTimeProperty.getHours() == 0
+                        && dateTimeProperty.getMinutes() == 0
+                        && dateTimeProperty.getSeconds() == 0
+                        && dateTimeProperty.getMilliseconds() == 0)
+    }
+}
diff --git a/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp b/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp
index 05ad5e2f2..8824dfd01 100644
--- a/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp
+++ b/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp
@@ -79,6 +79,10 @@ private slots:
     void assignDate();
     void exportDate_data();
     void exportDate();
+    void checkDate_data();
+    void checkDate();
+    void checkDateTime_data();
+    void checkDateTime();
     void idShortcutInvalidates();
     void boolPropertiesEvaluateAsBool();
     void methods();
@@ -568,6 +572,82 @@ void tst_qqmlecmascript::exportDate()
     QCOMPARE(object->boolProperty(), true);
 }
 
+void tst_qqmlecmascript::checkDate_data()
+{
+    QTest::addColumn<QUrl>("source");
+    QTest::addColumn<QDate>("date");
+    // NB: JavaScript month-indices are Jan = 0 to Dec = 11; QDate's are Jan = 1 to Dec = 12.
+    QTest::newRow("denormal-March")
+        << testFileUrl("checkDate-denormal-March.qml")
+        << QDate(2019, 3, 1);
+    QTest::newRow("denormal-leap")
+        << testFileUrl("checkDate-denormal-leap.qml")
+        << QDate(2020, 2, 29);
+    QTest::newRow("denormal-Feb")
+        << testFileUrl("checkDate-denormal-Feb.qml")
+        << QDate(2019, 2, 28);
+    QTest::newRow("denormal-year")
+        << testFileUrl("checkDate-denormal-year.qml")
+        << QDate(2019, 12, 31);
+    QTest::newRow("denormal-wrap")
+        << testFileUrl("checkDate-denormal-wrap.qml")
+        << QDate(2020, 2, 29);
+    QTest::newRow("October")
+        << testFileUrl("checkDate-October.qml")
+        << QDate(2019, 10, 3);
+}
+
+void tst_qqmlecmascript::checkDate()
+{
+    QFETCH(const QUrl, source);
+    QFETCH(const QDate, date);
+    QQmlEngine e;
+    QQmlComponent component(&e, source);
+    QScopedPointer<QObject> obj(component.create());
+    MyTypeObject *object = qobject_cast<MyTypeObject *>(obj.data());
+    QVERIFY(object != nullptr);
+    QCOMPARE(object->dateProperty(), date);
+    QVERIFY(object->boolProperty());
+}
+
+void tst_qqmlecmascript::checkDateTime_data()
+{
+    QTest::addColumn<QUrl>("source");
+    QTest::addColumn<QDateTime>("when");
+    // NB: JavaScript month-indices are Jan = 0 to Dec = 11; QDate's are Jan = 1 to Dec = 12.
+    QTest::newRow("denormal-March")
+        << testFileUrl("checkDateTime-denormal-March.qml")
+        << QDateTime(QDate(2019, 3, 1), QTime(0, 0, 0, 1), Qt::LocalTime);
+    QTest::newRow("denormal-leap")
+        << testFileUrl("checkDateTime-denormal-leap.qml")
+        << QDateTime(QDate(2020, 2, 29), QTime(23, 59, 59, 999), Qt::LocalTime);
+    QTest::newRow("denormal-hours")
+        << testFileUrl("checkDateTime-denormal-hours.qml")
+        << QDateTime(QDate(2020, 2, 29), QTime(0, 0), Qt::LocalTime);
+    QTest::newRow("denormal-minutes")
+        << testFileUrl("checkDateTime-denormal-minutes.qml")
+        << QDateTime(QDate(2020, 2, 29), QTime(0, 0), Qt::LocalTime);
+    QTest::newRow("denormal-seconds")
+        << testFileUrl("checkDateTime-denormal-seconds.qml")
+        << QDateTime(QDate(2020, 2, 29), QTime(0, 0), Qt::LocalTime);
+    QTest::newRow("October")
+        << testFileUrl("checkDateTime-October.qml")
+        << QDateTime(QDate(2019, 10, 3), QTime(12, 0), Qt::LocalTime);
+}
+
+void tst_qqmlecmascript::checkDateTime()
+{
+    QFETCH(const QUrl, source);
+    QFETCH(const QDateTime, when);
+    QQmlEngine e;
+    QQmlComponent component(&e, source);
+    QScopedPointer<QObject> obj(component.create());
+    MyTypeObject *object = qobject_cast<MyTypeObject *>(obj.data());
+    QVERIFY(object != nullptr);
+    QCOMPARE(object->dateTimeProperty(), when);
+    QVERIFY(object->boolProperty());
+}
+
 void tst_qqmlecmascript::idShortcutInvalidates()
 {
     QQmlEngine engine;
diff --git a/tests/auto/qml/qqmlengine/tst_qqmlengine.cpp b/tests/auto/qml/qqmlengine/tst_qqmlengine.cpp
index aae42e9eb..64f167b47 100644
--- a/tests/auto/qml/qqmlengine/tst_qqmlengine.cpp
+++ b/tests/auto/qml/qqmlengine/tst_qqmlengine.cpp
@@ -1107,6 +1107,16 @@ void tst_qqmlengine::singletonInstance()
         SomeQObjectClass * instance = engine.singletonInstance<SomeQObjectClass*>(cppSingletonTypeId);
         QVERIFY(!instance);
     }
+
+    {
+        // deleted object
+        auto dayfly = new QObject{};
+        auto id = qmlRegisterSingletonInstance("Vanity", 1, 0, "Dayfly", dayfly);
+        delete dayfly;
+        QTest::ignoreMessage(QtMsgType::QtWarningMsg, "<Unknown File>: The registered singleton has already been deleted. Ensure that it outlives the engine.");
+        QObject *instance = engine.singletonInstance<QObject*>(id);
+        QVERIFY(!instance);
+    }
 }
 
 void tst_qqmlengine::aggressiveGc()
diff --git a/tests/auto/qml/qqmllanguage/data/alias.17.qml b/tests/auto/qml/qqmllanguage/data/alias.17.qml
new file mode 100644
index 000000000..a76dd120b
--- /dev/null
+++ b/tests/auto/qml/qqmllanguage/data/alias.17.qml
@@ -0,0 +1,31 @@
+import QtQuick 2.12
+
+Item {
+    id: root
+    anchors.fill: parent
+    width: 100
+    height: 100
+    property bool success: checkValue === aliasUser.topMargin
+    property int checkValue: 42
+    Rectangle {
+        id: myItem
+        objectName: "myItem"
+        color: "blue"
+        anchors.topMargin: root.checkValue
+        width: 50
+        height: 50
+        Text {text: "source:\n" + myItem.anchors.topMargin}
+    }
+
+    Rectangle {
+        property alias topMargin: myItem.anchors.topMargin
+        id: aliasUser
+        objectName: "aliasUser"
+        color: "red"
+        anchors.left: myItem.right
+        width: 50
+        height: 50
+        Text {objectName: "myText"; text: "alias:\n" + aliasUser.topMargin}
+    }
+}
+
diff --git a/tests/auto/qml/qqmllanguage/data/fuzzed.3.errors.txt b/tests/auto/qml/qqmllanguage/data/fuzzed.3.errors.txt
new file mode 100644
index 000000000..da17dc559
--- /dev/null
+++ b/tests/auto/qml/qqmllanguage/data/fuzzed.3.errors.txt
@@ -0,0 +1,2 @@
+3:2:Unexpected token `version number'
+1:1:Expected a qualified name id or a string literal
diff --git a/tests/auto/qml/qqmllanguage/data/fuzzed.3.qml b/tests/auto/qml/qqmllanguage/data/fuzzed.3.qml
new file mode 100644
index 000000000..6861ebf8a
Binary files /dev/null and b/tests/auto/qml/qqmllanguage/data/fuzzed.3.qml differ
diff --git a/tests/auto/qml/qqmllanguage/data/objectValueTypeProperty.errors.txt b/tests/auto/qml/qqmllanguage/data/objectValueTypeProperty.errors.txt
index 043f71463..887d87b9f 100644
--- a/tests/auto/qml/qqmllanguage/data/objectValueTypeProperty.errors.txt
+++ b/tests/auto/qml/qqmllanguage/data/objectValueTypeProperty.errors.txt
@@ -1 +1 @@
-4:18:Can not assign value of type "MyTypeObject" to property "x", expecting "int"
+4:18:Cannot assign value of type "MyTypeObject" to property "x", expecting "int"
diff --git a/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp b/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp
index ad96b1438..fae74f1f2 100644
--- a/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp
+++ b/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp
@@ -621,6 +621,7 @@ void tst_qqmllanguage::errors_data()
 
     QTest::newRow("fuzzed.1") << "fuzzed.1.qml" << "fuzzed.1.errors.txt" << false;
     QTest::newRow("fuzzed.2") << "fuzzed.2.qml" << "fuzzed.2.errors.txt" << false;
+    QTest::newRow("fuzzed.3") << "fuzzed.3.qml" << "fuzzed.3.errors.txt" << false;
 
     QTest::newRow("bareQmlImport") << "bareQmlImport.qml" << "bareQmlImport.errors.txt" << false;
 
@@ -1969,6 +1970,69 @@ void tst_qqmllanguage::aliasProperties()
         QScopedPointer<QObject> object(component.create());
         QVERIFY(!object.isNull());
     }
+
+    // Alias to grouped property
+    {
+        QQmlComponent component(&engine, testFileUrl("alias.17.qml"));
+        VERIFY_ERRORS(0);
+
+        QScopedPointer<QObject> object(component.create());
+        QVERIFY(!object.isNull());
+        QVERIFY(object->property("success").toBool());
+    }
+
+    // Alias to grouped property updates
+    {
+        QQmlComponent component(&engine, testFileUrl("alias.17.qml"));
+        VERIFY_ERRORS(0);
+
+        QScopedPointer<QObject> object(component.create());
+        QVERIFY(!object.isNull());
+        QObject *aliasUser = object->findChild<QObject*>(QLatin1String("aliasUser"));
+        QVERIFY(aliasUser);
+        QQmlProperty checkValueProp(object.get(), "checkValue");
+        QVERIFY(checkValueProp.isValid());
+        checkValueProp.write(777);
+        QCOMPARE(object->property("checkValue").toInt(), 777);
+        QCOMPARE(aliasUser->property("topMargin").toInt(), 777);
+    }
+
+    // Write to alias to grouped property
+    {
+        QQmlComponent component(&engine, testFileUrl("alias.17.qml"));
+        VERIFY_ERRORS(0);
+
+        QScopedPointer<QObject> object(component.create());
+        QVERIFY(!object.isNull());
+        QObject *aliasUser = object->findChild<QObject*>(QLatin1String("aliasUser"));
+        QVERIFY(aliasUser);
+        QQmlProperty topMarginProp {aliasUser, "topMargin"};
+        QVERIFY(topMarginProp.isValid());
+        topMarginProp.write(777);
+        QObject *myItem = object->findChild<QObject*>(QLatin1String("myItem"));
+        QVERIFY(myItem);
+        auto anchors = myItem->property("anchors").value<QObject*>();
+        QVERIFY(anchors);
+        QCOMPARE(anchors->property("topMargin").toInt(), 777);
+    }
+
+    // Binding to alias to grouped property gets updated
+    {
+        QQmlComponent component(&engine, testFileUrl("alias.17.qml"));
+        VERIFY_ERRORS(0);
+
+        QScopedPointer<QObject> object(component.create());
+        QVERIFY(!object.isNull());
+        QObject *aliasUser = object->findChild<QObject*>(QLatin1String("aliasUser"));
+        QVERIFY(aliasUser);
+        QQmlProperty topMarginProp {aliasUser, "topMargin"};
+        QVERIFY(topMarginProp.isValid());
+        topMarginProp.write(20);
+        QObject *myText = object->findChild<QObject*>(QLatin1String("myText"));
+        QVERIFY(myText);
+        auto text = myText->property("text").toString();
+        QCOMPARE(text, "alias:\n20");
+    }
 }
 
 // QTBUG-13374 Test that alias properties and signals can coexist
diff --git a/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp b/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp
index 77ab0ecbc..75a932b6f 100644
--- a/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp
+++ b/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp
@@ -128,6 +128,8 @@ private slots:
     void qobjectTrackerForDynamicModelObjects();
     void crash_append_empty_array();
     void dynamic_roles_crash_QTBUG_38907();
+    void nestedListModelIteration();
+    void undefinedAppendShouldCauseError();
 };
 
 bool tst_qqmllistmodel::compareVariantList(const QVariantList &testList, QVariant object)
@@ -1667,6 +1669,61 @@ void tst_qqmllistmodel::dynamic_roles_crash_QTBUG_38907()
     QVERIFY(retVal.toBool());
 }
 
+void tst_qqmllistmodel::nestedListModelIteration()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine);
+    QTest::ignoreMessage(QtMsgType::QtDebugMsg ,R"({"subItems":[{"a":1,"b":0,"c":0},{"a":0,"b":2,"c":0},{"a":0,"b":0,"c":3}]})");
+    component.setData(
+            R"(import QtQuick 2.5
+            Item {
+                visible: true
+                width: 640
+                height: 480
+                ListModel {
+                    id : model
+                }
+                Component.onCompleted: {
+                        var tempData = {
+                            subItems: [{a: 1}, {b: 2}, {c: 3}]
+                        }
+                        model.insert(0, tempData)
+                        console.log(JSON.stringify(model.get(0)))
+                }
+            })",
+            QUrl());
+    QScopedPointer<QObject>(component.create());
+}
+
+// QTBUG-63569
+void tst_qqmllistmodel::undefinedAppendShouldCauseError()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine);
+    component.setData(
+            R"(import QtQuick 2.5
+            Item {
+                width: 640
+                height: 480
+                ListModel {
+                    id : model
+                }
+                Component.onCompleted: {
+                        var tempData = {
+                            faulty: undefined
+                        }
+                        model.insert(0, tempData)
+                        tempData.faulty = null
+                        model.insert(0, tempData)
+                }
+            })",
+            QUrl());
+    QTest::ignoreMessage(QtMsgType::QtWarningMsg, "<Unknown File>: faulty is undefined. Adding an object with a undefined member does not create a role for it.");
+    QTest::ignoreMessage(QtMsgType::QtWarningMsg, "<Unknown File>: faulty is null. Adding an object with a null member does not create a role for it.");
+    QScopedPointer<QObject>(component.create());
+}
+
+
 QTEST_MAIN(tst_qqmllistmodel)
 
 #include "tst_qqmllistmodel.moc"
diff --git a/tests/auto/qml/qqmlproperty/data/interfaceBinding.qml b/tests/auto/qml/qqmlproperty/data/interfaceBinding.qml
new file mode 100644
index 000000000..4e72a75f4
--- /dev/null
+++ b/tests/auto/qml/qqmlproperty/data/interfaceBinding.qml
@@ -0,0 +1,27 @@
+import QtQuick 2.12
+import io.qt.bugreports 1.0
+Item {
+    InterfaceConsumer {
+        objectName: "a1"
+        i: A {
+            property int i: 42
+        }
+    }
+
+    InterfaceConsumer {
+        objectName: "a2"
+        property A a: A {
+            property int i: 43
+        }
+        i: a
+    }
+
+    InterfaceConsumer {
+        objectName: "a3"
+        property A a: A {
+            id : aa
+            property int i: 44
+        }
+        i: aa
+    }
+}
diff --git a/tests/auto/qml/qqmlproperty/tst_qqmlproperty.cpp b/tests/auto/qml/qqmlproperty/tst_qqmlproperty.cpp
index bc407e97a..7ebe0bac5 100644
--- a/tests/auto/qml/qqmlproperty/tst_qqmlproperty.cpp
+++ b/tests/auto/qml/qqmlproperty/tst_qqmlproperty.cpp
@@ -40,6 +40,7 @@
 #endif
 #include <QtCore/private/qobject_p.h>
 #include "../../shared/util.h"
+#include "qobject.h"
 
 #include <QDebug>
 class MyQmlObject : public QObject
@@ -148,6 +149,7 @@ private slots:
     void readOnlyDynamicProperties();
     void aliasToIdWithMatchingQmlFileNameOnCaseInsensitiveFileSystem();
     void nullPropertyBinding();
+    void interfaceBinding();
 
     void floatToStringPrecision_data();
     void floatToStringPrecision();
@@ -2083,6 +2085,83 @@ void tst_qqmlproperty::nullPropertyBinding()
     QMetaObject::invokeMethod(root.get(), "tog");
 }
 
+struct Interface {
+};
+
+QT_BEGIN_NAMESPACE
+#define MyInterface_iid "io.qt.bugreports.Interface"
+Q_DECLARE_INTERFACE(Interface, MyInterface_iid);
+QT_END_NAMESPACE
+
+class A : public QObject, Interface {
+    Q_OBJECT
+    Q_INTERFACES(Interface)
+};
+
+class B : public QObject, Interface {
+    Q_OBJECT
+    Q_INTERFACES(Interface)
+};
+
+class C : public QObject {
+    Q_OBJECT
+};
+
+class InterfaceConsumer : public QObject {
+    Q_OBJECT
+    Q_PROPERTY(Interface* i READ interface WRITE setInterface NOTIFY interfaceChanged)
+    Q_PROPERTY(int testValue READ testValue NOTIFY testValueChanged)
+
+
+public:
+
+    Interface* interface() const
+    {
+        return m_interface;
+    }
+    void setInterface(Interface* interface)
+    {
+        QObject* object = reinterpret_cast<QObject*>(interface);
+        m_testValue = object->property("i").toInt();
+        emit testValueChanged();
+        if (m_interface == interface)
+            return;
+
+        m_interface = interface;
+        emit interfaceChanged();
+    }
+
+    int testValue() {
+        return m_testValue;
+    }
+
+signals:
+    void interfaceChanged();
+    void testValueChanged();
+
+private:
+    Interface* m_interface = nullptr;
+    int m_testValue = 0;
+};
+void tst_qqmlproperty::interfaceBinding()
+{
+
+        qmlRegisterInterface<Interface>("Interface");
+        qmlRegisterType<A>("io.qt.bugreports", 1, 0, "A");
+        qmlRegisterType<B>("io.qt.bugreports", 1, 0, "B");
+        qmlRegisterType<C>("io.qt.bugreports", 1, 0, "C");
+        qmlRegisterType<InterfaceConsumer>("io.qt.bugreports", 1, 0, "InterfaceConsumer");
+
+        const QUrl url = testFileUrl("interfaceBinding.qml");
+        QQmlEngine engine;
+        QQmlComponent component(&engine, url);
+        QScopedPointer<QObject> root(component.create());
+        QVERIFY(root);
+        QCOMPARE(root->findChild<QObject*>("a1")->property("testValue").toInt(), 42);
+        QCOMPARE(root->findChild<QObject*>("a2")->property("testValue").toInt(), 43);
+        QCOMPARE(root->findChild<QObject*>("a3")->property("testValue").toInt(), 44);
+}
+
 void tst_qqmlproperty::floatToStringPrecision_data()
 {
     QTest::addColumn<QString>("propertyName");
diff --git a/tests/auto/qml/qqmlvaluetypes/data/color_read.qml b/tests/auto/qml/qqmlvaluetypes/data/color_read.qml
index 73d2b921a..a2d303b50 100644
--- a/tests/auto/qml/qqmlvaluetypes/data/color_read.qml
+++ b/tests/auto/qml/qqmlvaluetypes/data/color_read.qml
@@ -12,4 +12,7 @@ MyTypeObject {
     property real hsl_s: color.hslSaturation
     property real hsl_l: color.hslLightness
     property variant copy: color
+
+    property bool valid: color.valid
+    property bool invalid: invalidColor.valid
 }
diff --git a/tests/auto/qml/qqmlvaluetypes/testtypes.h b/tests/auto/qml/qqmlvaluetypes/testtypes.h
index bcfe4028c..798c96e18 100644
--- a/tests/auto/qml/qqmlvaluetypes/testtypes.h
+++ b/tests/auto/qml/qqmlvaluetypes/testtypes.h
@@ -69,6 +69,7 @@ class MyTypeObject : public QObject
     Q_PROPERTY(QMatrix4x4 matrix READ matrix WRITE setMatrix NOTIFY changed)
     Q_PROPERTY(QFont font READ font WRITE setFont NOTIFY changed)
     Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY changed)
+    Q_PROPERTY(QColor invalidColor READ invalidColor CONSTANT)
     Q_PROPERTY(QVariant variant READ variant NOTIFY changed)
 
 public:
@@ -168,6 +169,8 @@ public:
     QColor color() const { return m_color; }
     void setColor(const QColor &v) { m_color = v; emit changed(); }
 
+    QColor invalidColor() const { return QColor(); }
+
     QVariant variant() const { return sizef(); }
 
     void emitRunScript() { emit runScript(); }
diff --git a/tests/auto/qml/qqmlvaluetypes/tst_qqmlvaluetypes.cpp b/tests/auto/qml/qqmlvaluetypes/tst_qqmlvaluetypes.cpp
index a55da25a9..3e9047cc5 100644
--- a/tests/auto/qml/qqmlvaluetypes/tst_qqmlvaluetypes.cpp
+++ b/tests/auto/qml/qqmlvaluetypes/tst_qqmlvaluetypes.cpp
@@ -935,6 +935,11 @@ void tst_qqmlvaluetypes::color()
         QCOMPARE(qRound(object->property("hsl_s").toDouble() * 100), 74);
         QCOMPARE(qRound(object->property("hsl_l").toDouble() * 100), 54);
 
+        QCOMPARE(object->property("valid").userType(), QMetaType::Bool);
+        QVERIFY(object->property("valid").toBool());
+        QCOMPARE(object->property("invalid").userType(), QMetaType::Bool);
+        QVERIFY(!object->property("invalid").toBool());
+
         QColor comparison;
         comparison.setRedF(0.2);
         comparison.setGreenF(0.88);
diff --git a/tests/auto/qml/qv4identifiertable/tst_qv4identifiertable.cpp b/tests/auto/qml/qv4identifiertable/tst_qv4identifiertable.cpp
index 308fba904..157d0f2a6 100644
--- a/tests/auto/qml/qv4identifiertable/tst_qv4identifiertable.cpp
+++ b/tests/auto/qml/qv4identifiertable/tst_qv4identifiertable.cpp
@@ -1,5 +1,6 @@
 /****************************************************************************
 **
+** Copyright (C) 2019 The Qt Company Ltd.
 ** Copyright (C) 2016 basysKom GmbH.
 ** Contact: https://www.qt.io/licensing/
 **
@@ -110,8 +111,8 @@ void tst_qv4identifiertable::sweepCenterEntryInBucket()
     table.asPropertyKey(entry2);
     table.asPropertyKey(entry3);
 
-    QCOMPARE(table.size, 3);
-    QCOMPARE(table.alloc, 5);
+    QCOMPARE(table.size, 3u);
+    QCOMPARE(table.alloc, 5u);
 
     QCOMPARE(table.entriesByHash[0], entry1);
     QCOMPARE(table.entriesByHash[1], entry2);
@@ -153,8 +154,8 @@ void tst_qv4identifiertable::sweepLastEntryInBucket()
     table.asPropertyKey(entry2);
     table.asPropertyKey(entry3);
 
-    QCOMPARE(table.size, 3);
-    QCOMPARE(table.alloc, 5);
+    QCOMPARE(table.size, 3u);
+    QCOMPARE(table.alloc, 5u);
 
     QCOMPARE(table.entriesByHash[0], entry1);
     QCOMPARE(table.entriesByHash[1], entry2);
@@ -193,8 +194,8 @@ void tst_qv4identifiertable::sweepFirstEntryInSameBucketWithDifferingHash()
     table.asPropertyKey(entry1);
     table.asPropertyKey(entry2);
 
-    QCOMPARE(table.size, 2);
-    QCOMPARE(table.alloc, 5);
+    QCOMPARE(table.size, 2u);
+    QCOMPARE(table.alloc, 5u);
 
     QCOMPARE(table.entriesByHash[0], entry1);
     QCOMPARE(table.entriesByHash[1], entry2);
@@ -231,8 +232,8 @@ void tst_qv4identifiertable::dontSweepAcrossBucketBoundaries()
     table.asPropertyKey(entry1);
     table.asPropertyKey(entry2);
 
-    QCOMPARE(table.size, 2);
-    QCOMPARE(table.alloc, 5);
+    QCOMPARE(table.size, 2u);
+    QCOMPARE(table.alloc, 5u);
 
     QCOMPARE(table.entriesByHash[0], entry1);
     QCOMPARE(table.entriesByHash[1], entry2);
@@ -279,8 +280,8 @@ void tst_qv4identifiertable::sweepAcrossBucketBoundariesIfFirstBucketFull()
     table.asPropertyKey(entry3);
     table.asPropertyKey(entry4);
 
-    QCOMPARE(table.size, 4);
-    QCOMPARE(table.alloc, 11);
+    QCOMPARE(table.size, 4u);
+    QCOMPARE(table.alloc, 11u);
 
     QCOMPARE(table.entriesByHash[0], entry1);
     QCOMPARE(table.entriesByHash[1], entry2);
@@ -336,8 +337,8 @@ void tst_qv4identifiertable::sweepBucketGap()
     table.asPropertyKey(entry3);
     table.asPropertyKey(entry4);
 
-    QCOMPARE(table.size, 4);
-    QCOMPARE(table.alloc, 11);
+    QCOMPARE(table.size, 4u);
+    QCOMPARE(table.alloc, 11u);
 
     QCOMPARE(table.entriesByHash[0], entry1);
     QCOMPARE(table.entriesByHash[1], entry2);
diff --git a/tests/auto/quick/qquickdrag/tst_qquickdrag.cpp b/tests/auto/quick/qquickdrag/tst_qquickdrag.cpp
index 9d832066a..ee43e5e06 100644
--- a/tests/auto/quick/qquickdrag/tst_qquickdrag.cpp
+++ b/tests/auto/quick/qquickdrag/tst_qquickdrag.cpp
@@ -598,7 +598,7 @@ void tst_QQuickDrag::move()
     QCoreApplication::processEvents();
     QCOMPARE(evaluate<QObject *>(item, "Drag.target"), static_cast<QObject *>(&rightTarget));
     QCOMPARE(evaluate<QObject *>(item, "dragTarget"), static_cast<QObject *>(&rightTarget));
-    QCOMPARE(outerTarget.enterEvents, 0); QCOMPARE(outerTarget.leaveEvents, 0); QCOMPARE(outerTarget.moveEvents, 0);
+    QCOMPARE(outerTarget.enterEvents, 0); QCOMPARE(outerTarget.leaveEvents, 1); QCOMPARE(outerTarget.moveEvents, 0);
     QCOMPARE(leftTarget .enterEvents, 0); QCOMPARE(leftTarget .leaveEvents, 0); QCOMPARE(leftTarget .moveEvents, 0);
     QCOMPARE(rightTarget.enterEvents, 1); QCOMPARE(rightTarget.leaveEvents, 0); QCOMPARE(rightTarget.moveEvents, 0);
     QCOMPARE(rightTarget.position.x(), qreal(5)); QCOMPARE(rightTarget.position.y(), qreal(15));
@@ -620,10 +620,10 @@ void tst_QQuickDrag::move()
     QCoreApplication::processEvents();
     QCOMPARE(evaluate<QObject *>(item, "Drag.target"), static_cast<QObject *>(&leftTarget));
     QCOMPARE(evaluate<QObject *>(item, "dragTarget"), static_cast<QObject *>(&leftTarget));
-    QCOMPARE(outerTarget.enterEvents, 0); QCOMPARE(outerTarget.leaveEvents, 0); QCOMPARE(outerTarget.moveEvents, 1);
+    QCOMPARE(outerTarget.enterEvents, 0); QCOMPARE(outerTarget.leaveEvents, 0); QCOMPARE(outerTarget.moveEvents, 0);
     QCOMPARE(leftTarget .enterEvents, 0); QCOMPARE(leftTarget .leaveEvents, 0); QCOMPARE(leftTarget .moveEvents, 1);
     QCOMPARE(rightTarget.enterEvents, 0); QCOMPARE(rightTarget.leaveEvents, 0); QCOMPARE(rightTarget.moveEvents, 0);
-    QCOMPARE(outerTarget.position.x(), qreal(25)); QCOMPARE(outerTarget.position.y(), qreal(40));
+    QCOMPARE(outerTarget.position.x(), qreal(60)); QCOMPARE(outerTarget.position.y(), qreal(50));
     QCOMPARE(leftTarget.position.x(), qreal(25)); QCOMPARE(leftTarget.position.y(), qreal(5));
 
     // Move out of all targets.
@@ -632,7 +632,7 @@ void tst_QQuickDrag::move()
     QCoreApplication::processEvents();
     QCOMPARE(evaluate<QObject *>(item, "Drag.target"), static_cast<QObject *>(nullptr));
     QCOMPARE(evaluate<QObject *>(item, "dragTarget"), static_cast<QObject *>(nullptr));
-    QCOMPARE(outerTarget.enterEvents, 0); QCOMPARE(outerTarget.leaveEvents, 1); QCOMPARE(outerTarget.moveEvents, 0);
+    QCOMPARE(outerTarget.enterEvents, 0); QCOMPARE(outerTarget.leaveEvents, 0); QCOMPARE(outerTarget.moveEvents, 0);
     QCOMPARE(leftTarget .enterEvents, 0); QCOMPARE(leftTarget .leaveEvents, 1); QCOMPARE(leftTarget .moveEvents, 0);
     QCOMPARE(rightTarget.enterEvents, 0); QCOMPARE(rightTarget.leaveEvents, 0); QCOMPARE(rightTarget.moveEvents, 0);
 
diff --git a/tests/auto/quick/qquickdroparea/data/nested1.qml b/tests/auto/quick/qquickdroparea/data/nested1.qml
new file mode 100644
index 000000000..de6ac70d0
--- /dev/null
+++ b/tests/auto/quick/qquickdroparea/data/nested1.qml
@@ -0,0 +1,93 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:BSD$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** BSD License Usage
+** Alternatively, you may use this file under the terms of the BSD license
+** as follows:
+**
+** "Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are
+** met:
+**   * Redistributions of source code must retain the above copyright
+**     notice, this list of conditions and the following disclaimer.
+**   * Redistributions in binary form must reproduce the above copyright
+**     notice, this list of conditions and the following disclaimer in
+**     the documentation and/or other materials provided with the
+**     distribution.
+**   * Neither the name of The Qt Company Ltd nor the names of its
+**     contributors may be used to endorse or promote products derived
+**     from this software without specific prior written permission.
+**
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+import QtQuick 2.0
+
+Item {
+    width: 200; height: 200
+    property int outerEnterEvents: 0
+    property int outerExitEvents: 0
+    property int innerEnterEvents: 0
+    property int innerExitEvents: 0
+
+    DropArea {
+        objectName: "outerDropArea"
+        x: 75; y: 75
+        width: 100; height: 100
+        Rectangle {
+            anchors.fill: parent
+            color: "green"
+        }
+        onEntered: ++outerEnterEvents
+        onExited: ++outerExitEvents
+
+        DropArea {
+            objectName: "innerDropArea"
+            width: 50; height: 50
+            Rectangle {
+                anchors.fill: parent
+                color: "blue"
+            }
+            onEntered: ++innerEnterEvents
+            onExited: ++innerExitEvents
+        }
+    }
+
+    Rectangle {
+        width: 20; height: 20
+        color: dragArea.pressed ? "red" : "brown"
+        Drag.active: dragArea.drag.active
+        MouseArea {
+            id: dragArea
+            objectName: "dragArea"
+            anchors.fill: parent
+            drag.target: parent
+        }
+    }
+}
diff --git a/tests/auto/quick/qquickdroparea/data/nested2.qml b/tests/auto/quick/qquickdroparea/data/nested2.qml
new file mode 100644
index 000000000..93630c377
--- /dev/null
+++ b/tests/auto/quick/qquickdroparea/data/nested2.qml
@@ -0,0 +1,93 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:BSD$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** BSD License Usage
+** Alternatively, you may use this file under the terms of the BSD license
+** as follows:
+**
+** "Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are
+** met:
+**   * Redistributions of source code must retain the above copyright
+**     notice, this list of conditions and the following disclaimer.
+**   * Redistributions in binary form must reproduce the above copyright
+**     notice, this list of conditions and the following disclaimer in
+**     the documentation and/or other materials provided with the
+**     distribution.
+**   * Neither the name of The Qt Company Ltd nor the names of its
+**     contributors may be used to endorse or promote products derived
+**     from this software without specific prior written permission.
+**
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+import QtQuick 2.0
+
+Item {
+    width: 200; height: 200
+    property int outerEnterEvents: 0
+    property int outerExitEvents: 0
+    property int innerEnterEvents: 0
+    property int innerExitEvents: 0
+
+    Rectangle {
+        x: 75; y: 75
+        width: 100; height: 100
+        color: "green"
+        DropArea {
+            objectName: "outerDropArea"
+            anchors.fill: parent
+            onEntered: ++outerEnterEvents
+            onExited: ++outerExitEvents
+        }
+
+        Rectangle {
+            width: 50; height: 50
+            color: "blue"
+            DropArea {
+                objectName: "innerDropArea"
+                anchors.fill: parent
+                onEntered: ++innerEnterEvents
+                onExited: ++innerExitEvents
+            }
+        }
+    }
+
+    Rectangle {
+        width: 20; height: 20
+        color: dragArea.pressed ? "red" : "brown"
+        Drag.active: dragArea.drag.active
+        MouseArea {
+            id: dragArea
+            objectName: "dragArea"
+            anchors.fill: parent
+            drag.target: parent
+        }
+    }
+}
diff --git a/tests/auto/quick/qquickdroparea/qquickdroparea.pro b/tests/auto/quick/qquickdroparea/qquickdroparea.pro
index a34d5ad00..7a8fdef7b 100644
--- a/tests/auto/quick/qquickdroparea/qquickdroparea.pro
+++ b/tests/auto/quick/qquickdroparea/qquickdroparea.pro
@@ -4,4 +4,11 @@ macx:CONFIG -= app_bundle
 
 SOURCES += tst_qquickdroparea.cpp
 
+OTHER_FILES += $$files(data/*.qml)
+
+include (../../shared/util.pri)
+include (../shared/util.pri)
+
+TESTDATA = data/*
+
 QT += core-private gui-private qml-private quick-private network testlib
diff --git a/tests/auto/quick/qquickdroparea/tst_qquickdroparea.cpp b/tests/auto/quick/qquickdroparea/tst_qquickdroparea.cpp
index cf01cc927..dcba4c872 100644
--- a/tests/auto/quick/qquickdroparea/tst_qquickdroparea.cpp
+++ b/tests/auto/quick/qquickdroparea/tst_qquickdroparea.cpp
@@ -28,6 +28,7 @@
 
 #include <QtTest/QtTest>
 #include <QtTest/QSignalSpy>
+#include <QtGui/qstylehints.h>
 #include <QtQuick/qquickitem.h>
 #include <QtQuick/qquickview.h>
 #include <QtQml/qqmlcontext.h>
@@ -36,6 +37,8 @@
 
 #include <qpa/qplatformdrag.h>
 #include <qpa/qwindowsysteminterface.h>
+#include "../../shared/util.h"
+#include "../shared/viewtestutil.h"
 
 template <typename T> static T evaluate(QObject *scope, const QString &expression)
 {
@@ -54,13 +57,10 @@ template <> void evaluate<void>(QObject *scope, const QString &expression)
         qWarning() << expr.error().toString();
 }
 
-class tst_QQuickDropArea: public QObject
+class tst_QQuickDropArea: public QQmlDataTest
 {
     Q_OBJECT
 private slots:
-    void initTestCase();
-    void cleanupTestCase();
-
     void containsDrag_internal();
     void containsDrag_external();
     void keys_internal();
@@ -74,21 +74,13 @@ private slots:
     void competingDrags();
     void simultaneousDrags();
     void dropStuff();
+    void nestedDropAreas_data();
+    void nestedDropAreas();
 
 private:
     QQmlEngine engine;
 };
 
-void tst_QQuickDropArea::initTestCase()
-{
-
-}
-
-void tst_QQuickDropArea::cleanupTestCase()
-{
-
-}
-
 void tst_QQuickDropArea::containsDrag_internal()
 {
     QQuickWindow window;
@@ -1224,6 +1216,74 @@ void tst_QQuickDropArea::dropStuff()
     QCOMPARE(evaluate<QByteArray>(dropArea, "array"), QByteArray("red"));
 }
 
+void tst_QQuickDropArea::nestedDropAreas_data()
+{
+    QTest::addColumn<QString>("qmlFile");
+
+    QTest::newRow("dropRectDropRect") << "nested1.qml";
+    QTest::newRow("rectDropRectDrop") << "nested2.qml";
+}
+
+void tst_QQuickDropArea::nestedDropAreas()
+{
+    QFETCH(QString, qmlFile);
+
+    const int dragThreshold = QGuiApplication::styleHints()->startDragDistance();
+    QQuickView window;
+    QByteArray errorMessage;
+    QVERIFY2(QQuickTest::initView(window, testFileUrl(qmlFile.toLatin1().data()), true, &errorMessage), errorMessage.constData());
+
+    window.show();
+    QVERIFY(QTest::qWaitForWindowExposed(&window));
+    QVERIFY(window.rootObject() != nullptr);
+
+    QQuickItem *dragArea = window.rootObject()->findChild<QQuickItem*>("dragArea");
+    QVERIFY(dragArea);
+    QQuickItem *outerDropArea = window.rootObject()->findChild<QQuickItem*>("outerDropArea");
+    QVERIFY(outerDropArea);
+    QQuickItem *innerDropArea = window.rootObject()->findChild<QQuickItem*>("innerDropArea");
+    QVERIFY(innerDropArea);
+
+    QPoint p = QPoint(10,10);
+    QTest::mousePress(&window, Qt::LeftButton, Qt::NoModifier, p);
+
+    // move the minimum distance to activate drag
+    p += QPoint(dragThreshold + 1, dragThreshold + 1);
+    QTest::mouseMove(&window, p);
+
+    // drag the red rectangle into the inner DropArea
+    p += QPoint(100, 100);
+    QTest::mouseMove(&window, p);
+    QCOMPARE(window.rootObject()->property("outerEnterEvents"), 0);
+    QCOMPARE(window.rootObject()->property("outerExitEvents"), 0);
+    QCOMPARE(window.rootObject()->property("innerEnterEvents"), 1);
+    QCOMPARE(window.rootObject()->property("innerExitEvents"), 0);
+
+    // drag the red rectangle into the outer DropArea
+    p += QPoint(0, 50);
+    QTest::mouseMove(&window, p);
+    QCOMPARE(window.rootObject()->property("outerEnterEvents"), 1);
+    QCOMPARE(window.rootObject()->property("outerExitEvents"), 0);
+    QCOMPARE(window.rootObject()->property("innerEnterEvents"), 1);
+    QCOMPARE(window.rootObject()->property("innerExitEvents"), 1);
+
+    // drag the red rectangle into the inner DropArea
+    p -= QPoint(0, 50);
+    QTest::mouseMove(&window, p);
+    QCOMPARE(window.rootObject()->property("outerEnterEvents"), 1);
+    QCOMPARE(window.rootObject()->property("outerExitEvents"), 1);
+    QCOMPARE(window.rootObject()->property("innerEnterEvents"), 2);
+    QCOMPARE(window.rootObject()->property("innerExitEvents"), 1);
+
+    // drag the red rectangle back out of both
+    p -= QPoint(100, 100);
+    QTest::mouseMove(&window, p);
+    QCOMPARE(window.rootObject()->property("outerEnterEvents"), 1);
+    QCOMPARE(window.rootObject()->property("outerExitEvents"), 1);
+    QCOMPARE(window.rootObject()->property("innerEnterEvents"), 2);
+    QCOMPARE(window.rootObject()->property("innerExitEvents"), 2);
+}
+
 QTEST_MAIN(tst_QQuickDropArea)
 
 #include "tst_qquickdroparea.moc"
diff --git a/tests/auto/quick/qquicklistview/tst_qquicklistview.cpp b/tests/auto/quick/qquicklistview/tst_qquicklistview.cpp
index 08149a178..ca438a9cd 100644
--- a/tests/auto/quick/qquicklistview/tst_qquicklistview.cpp
+++ b/tests/auto/quick/qquicklistview/tst_qquicklistview.cpp
@@ -1943,6 +1943,31 @@ void tst_QQuickListView::enforceRange()
 
     QTRY_COMPARE(listview->currentIndex(), 6);
 
+    // Test for [QTBUG-77418] {
+        // explicit set current index
+        listview->setCurrentIndex(5);
+        QTRY_COMPARE(listview->contentY(), 0);
+
+        // then check if contentY changes if the highlight range is changed
+        listview->setPreferredHighlightBegin(80);
+        listview->setPreferredHighlightEnd(80);
+        QTRY_COMPARE(listview->contentY(), 20);
+
+        // verify that current index does not change with no highlight
+        listview->setHighlightRangeMode(QQuickListView::NoHighlightRange);
+        listview->setContentY(100);
+        QTRY_COMPARE(listview->currentIndex(), 5);
+
+        // explicit set current index, contentY should not change now
+        listview->setCurrentIndex(6);
+        QTRY_COMPARE(listview->contentY(), 100);
+        QTest::qWait(50);   // This was needed in order to reproduce a failure for the following test
+
+        // verify that contentY changes if we turn on highlight again
+        listview->setHighlightRangeMode(QQuickListView::StrictlyEnforceRange);
+        QTRY_COMPARE(listview->contentY(), 40);
+    // } Test for [QTBUG-77418]
+
     // change model
     QaimModel model2;
     for (int i = 0; i < 5; i++)
diff --git a/tests/auto/quick/qquickpathview/tst_qquickpathview.cpp b/tests/auto/quick/qquickpathview/tst_qquickpathview.cpp
index 8a1ab4047..4498548d4 100644
--- a/tests/auto/quick/qquickpathview/tst_qquickpathview.cpp
+++ b/tests/auto/quick/qquickpathview/tst_qquickpathview.cpp
@@ -1614,16 +1614,55 @@ void tst_QQuickPathView::flickNClick() // QTBUG-77173
 
     QQuickPathView *pathview = qobject_cast<QQuickPathView*>(window->rootObject());
     QVERIFY(pathview != nullptr);
+    QSignalSpy movingChangedSpy(pathview, SIGNAL(movingChanged()));
+    QSignalSpy draggingSpy(pathview, SIGNAL(draggingChanged()));
+    QSignalSpy dragStartedSpy(pathview, SIGNAL(dragStarted()));
+    QSignalSpy dragEndedSpy(pathview, SIGNAL(dragEnded()));
+    QSignalSpy currentIndexSpy(pathview, SIGNAL(currentIndexChanged()));
+    QSignalSpy moveStartedSpy(pathview, SIGNAL(movementStarted()));
+    QSignalSpy moveEndedSpy(pathview, SIGNAL(movementEnded()));
+    QSignalSpy flickingSpy(pathview, SIGNAL(flickingChanged()));
+    QSignalSpy flickStartedSpy(pathview, SIGNAL(flickStarted()));
+    QSignalSpy flickEndedSpy(pathview, SIGNAL(flickEnded()));
 
     for (int duration = 100; duration > 0; duration -= 20) {
+        movingChangedSpy.clear();
+        draggingSpy.clear();
+        dragStartedSpy.clear();
+        dragEndedSpy.clear();
+        currentIndexSpy.clear();
+        moveStartedSpy.clear();
+        moveEndedSpy.clear();
+        flickingSpy.clear();
+        flickStartedSpy.clear();
+        flickEndedSpy.clear();
         // Dragging the child mouse area should animate the PathView (MA has no drag target)
         flick(window.data(), QPoint(200,200), QPoint(400,200), duration);
         QVERIFY(pathview->isMoving());
+        QCOMPARE(movingChangedSpy.count(), 1);
+        QCOMPARE(draggingSpy.count(), 2);
+        QCOMPARE(dragStartedSpy.count(), 1);
+        QCOMPARE(dragEndedSpy.count(), 1);
+        QVERIFY(currentIndexSpy.count() > 0);
+        QCOMPARE(moveStartedSpy.count(), 1);
+        QCOMPARE(moveEndedSpy.count(), 0);
+        QCOMPARE(flickingSpy.count(), 1);
+        QCOMPARE(flickStartedSpy.count(), 1);
+        QCOMPARE(flickEndedSpy.count(), 0);
 
         // Now while it's still moving, click it.
         // The PathView should stop at a position such that offset is a whole number.
         QTest::mouseClick(window.data(), Qt::LeftButton, Qt::NoModifier, QPoint(200, 200));
         QTRY_VERIFY(!pathview->isMoving());
+        QCOMPARE(movingChangedSpy.count(), 2); // QTBUG-78926
+        QCOMPARE(draggingSpy.count(), 2);
+        QCOMPARE(dragStartedSpy.count(), 1);
+        QCOMPARE(dragEndedSpy.count(), 1);
+        QCOMPARE(moveStartedSpy.count(), 1);
+        QCOMPARE(moveEndedSpy.count(), 1);
+        QCOMPARE(flickingSpy.count(), 2);
+        QCOMPARE(flickStartedSpy.count(), 1);
+        QCOMPARE(flickEndedSpy.count(), 1);
         QVERIFY(qFuzzyIsNull(pathview->offset() - int(pathview->offset())));
     }
 }
diff --git a/tests/auto/quick/qquicktextinput/data/qtbug77841.qml b/tests/auto/quick/qquicktextinput/data/qtbug77841.qml
new file mode 100644
index 000000000..ebb43a8f8
--- /dev/null
+++ b/tests/auto/quick/qquicktextinput/data/qtbug77841.qml
@@ -0,0 +1,22 @@
+import QtQuick 2.12
+
+Item {
+    id: root
+    width: 600
+    height: 300
+
+    TextInput {
+        id: qwe
+        objectName: "qwe"
+        width: 500
+        height: 100
+        font.pixelSize: 50
+        text: "123456"
+        focus: true
+    }
+
+    Component.onCompleted: {
+        qwe.insert(0, "***")
+        qwe.remove(0, 3)
+    }
+}
diff --git a/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp b/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp
index ed2d535fd..cab4e1145 100644
--- a/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp
+++ b/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp
@@ -230,6 +230,7 @@ private slots:
     void padding();
 
     void QTBUG_51115_readOnlyResetsSelection();
+    void QTBUG_77814_InsertRemoveNoSelection();
 
 private:
     void simulateKey(QWindow *, int key);
@@ -7003,6 +7004,18 @@ void tst_qquicktextinput::QTBUG_51115_readOnlyResetsSelection()
     QCOMPARE(obj->selectedText(), QString());
 }
 
+void tst_qquicktextinput::QTBUG_77814_InsertRemoveNoSelection()
+{
+    QQuickView view;
+    view.setSource(testFileUrl("qtbug77841.qml"));
+    view.show();
+    QVERIFY(QTest::qWaitForWindowExposed(&view));
+    QQuickTextInput *textInput = view.rootObject()->findChild<QQuickTextInput*>("qwe");
+    QVERIFY(textInput);
+
+    QCOMPARE(textInput->selectedText(), QString());
+}
+
 QTEST_MAIN(tst_qquicktextinput)
 
 #include "tst_qquicktextinput.moc"
diff --git a/tests/auto/quick/qquickvisualdatamodel/tst_qquickvisualdatamodel.cpp b/tests/auto/quick/qquickvisualdatamodel/tst_qquickvisualdatamodel.cpp
index 32008f675..fe56cad01 100644
--- a/tests/auto/quick/qquickvisualdatamodel/tst_qquickvisualdatamodel.cpp
+++ b/tests/auto/quick/qquickvisualdatamodel/tst_qquickvisualdatamodel.cpp
@@ -432,6 +432,7 @@ private slots:
     void asynchronousCancel();
     void invalidContext();
     void externalManagedModel();
+    void delegateModelChangeDelegate();
 
 private:
     template <int N> void groups_verify(
@@ -4302,6 +4303,45 @@ void tst_qquickvisualdatamodel::externalManagedModel()
     QTRY_VERIFY(!object->property("running").toBool());
 }
 
+void tst_qquickvisualdatamodel::delegateModelChangeDelegate()
+{
+    // Verify that QTBUG-63477 is fixed.
+    // Changing the delegate would not update existing items.
+    QQmlEngine engine;
+    QScopedPointer<QQmlContext> context(new QQmlContext(engine.rootContext()));
+
+    QQmlComponent c(&engine);
+    c.setData("import QtQml.Models 2.2\nDelegateModel {}\n", QUrl());
+    QCOMPARE(c.status(), QQmlComponent::Ready);
+
+    QQmlDelegateModel *visualModel = qobject_cast<QQmlDelegateModel*>(c.create(context.data()));
+    QVERIFY(visualModel);
+    visualModel->setModel(QVariant(3));
+
+    QQmlComponent first(&engine);
+    first.setData("import QtQuick 2.0\nItem { objectName: \"old\" }\n", QUrl());
+    QCOMPARE(first.status(), QQmlComponent::Ready);
+
+    // Without delegate, claim to have an item count of 0
+    QCOMPARE(visualModel->count(), 0);
+
+    visualModel->setDelegate(&first);
+    // The first delegate has been set, verify we get it
+    QObject* old = visualModel->object(0, QQmlIncubator::Synchronous);
+    QVERIFY(old);
+    QCOMPARE(visualModel->object(0, QQmlIncubator::Synchronous)->objectName(), QStringLiteral("old"));
+    QCOMPARE(visualModel->count(), 3);
+
+    QQmlComponent second(&engine);
+    second.setData("import QtQuick 2.0\nItem { objectName: \"new\" }\n", QUrl());
+    QCOMPARE(second.status(), QQmlComponent::Ready);
+
+    visualModel->setDelegate(&second);
+    // After changing the delegate, expect the existing item to have the new delegate
+    QCOMPARE(visualModel->object(0, QQmlIncubator::Synchronous)->objectName(), QStringLiteral("new"));
+    QCOMPARE(visualModel->count(), 3);
+}
+
 QTEST_MAIN(tst_qquickvisualdatamodel)
 
 #include "tst_qquickvisualdatamodel.moc"
diff --git a/tests/auto/quick/qquickwindow/data/shortcut.qml b/tests/auto/quick/qquickwindow/data/shortcut.qml
new file mode 100644
index 000000000..2632e2785
--- /dev/null
+++ b/tests/auto/quick/qquickwindow/data/shortcut.qml
@@ -0,0 +1,47 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+import QtQuick 2.9
+import QtQuick.Window 2.2
+
+Window {
+    id: root
+    visible: true
+    width: 200
+    height: 200
+    property bool received: false
+    Item {
+        focus: true
+        Shortcut {
+            sequence: "B"
+            onActivated: {
+                root.received = true
+            }
+        }
+    }
+}
+
diff --git a/tests/auto/quick/qquickwindow/tst_qquickwindow.cpp b/tests/auto/quick/qquickwindow/tst_qquickwindow.cpp
index f08b9207d..7faa621e8 100644
--- a/tests/auto/quick/qquickwindow/tst_qquickwindow.cpp
+++ b/tests/auto/quick/qquickwindow/tst_qquickwindow.cpp
@@ -482,6 +482,10 @@ private slots:
     void testChildMouseEventFilter_data();
     void cleanupGrabsOnRelease();
 
+#if QT_CONFIG(shortcut)
+    void testShortCut();
+#endif
+
 private:
     QTouchDevice *touchDevice;
     QTouchDevice *touchDeviceWithVelocity;
@@ -3579,6 +3583,30 @@ void tst_qquickwindow::cleanupGrabsOnRelease()
     QCOMPARE(parent->mouseUngrabEventCount, 1);
 }
 
+#if QT_CONFIG(shortcut)
+void tst_qquickwindow::testShortCut()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine);
+    component.loadUrl(testFileUrl("shortcut.qml"));
+
+    QObject *created = component.create();
+    QScopedPointer<QObject> cleanup(created);
+    QVERIFY(created);
+
+    QQuickWindow *window = qobject_cast<QQuickWindow *>(created);
+    QVERIFY(QTest::qWaitForWindowActive(window));
+
+    EventFilter eventFilter;
+    window->activeFocusItem()->installEventFilter(&eventFilter);
+    //Send non-spontaneous key press event
+    QKeyEvent keyEvent(QEvent::KeyPress, Qt::Key_B, Qt::NoModifier);
+    QCoreApplication::sendEvent(window, &keyEvent);
+    QVERIFY(eventFilter.events.contains(int(QEvent::ShortcutOverride)));
+    QVERIFY(window->property("received").value<bool>());
+}
+#endif
+
 QTEST_MAIN(tst_qquickwindow)
 
 #include "tst_qquickwindow.moc"
diff --git a/tools/qmlplugindump/main.cpp b/tools/qmlplugindump/main.cpp
index 5e999c557..155671847 100644
--- a/tools/qmlplugindump/main.cpp
+++ b/tools/qmlplugindump/main.cpp
@@ -380,23 +380,21 @@ public:
         relocatableModuleUri = uri;
     }
 
-    const QString getExportString(QString qmlTyName, int majorVersion, int minorVersion)
+    QString getExportString(const QQmlType &type, const QmlVersionInfo &versionInfo)
     {
-        if (qmlTyName.startsWith(relocatableModuleUri + QLatin1Char('/'))) {
-            qmlTyName.remove(0, relocatableModuleUri.size() + 1);
-        }
-        if (qmlTyName.startsWith("./")) {
-            qmlTyName.remove(0, 2);
-        }
-        if (qmlTyName.startsWith(QLatin1Char('/'))) {
-            qmlTyName.remove(0, 1);
-        }
-        const QString exportString = enquote(
-                    QString("%1 %2.%3").arg(
-                        qmlTyName,
-                        QString::number(majorVersion),
-                        QString::number(minorVersion)));
-        return exportString;
+        const QString module = type.module().isEmpty() ? versionInfo.pluginImportUri
+                                                       : type.module();
+        const int majorVersion = type.majorVersion() >= 0 ? type.majorVersion()
+                                                          : versionInfo.majorVersion;
+        const int minorVersion = type.minorVersion() >= 0 ? type.minorVersion()
+                                                          : versionInfo.minorVersion;
+
+        const QString versionedElement = type.elementName()
+                + QString::fromLatin1(" %1.%2").arg(majorVersion).arg(minorVersion);
+
+        return enquote((module == relocatableModuleUri)
+                       ? versionedElement
+                       : module + QLatin1Char('/') + versionedElement);
     }
 
     void writeMetaContent(const QMetaObject *meta, KnownAttributes *knownAttributes = nullptr)
@@ -441,8 +439,9 @@ public:
         }
     }
 
-    QString getPrototypeNameForCompositeType(const QMetaObject *metaObject, QSet<QByteArray> &defaultReachableNames,
-                                             QList<const QMetaObject *> *objectsToMerge, const QmlVersionInfo &versionInfo)
+    QString getPrototypeNameForCompositeType(
+            const QMetaObject *metaObject, QList<const QMetaObject *> *objectsToMerge,
+            const QmlVersionInfo &versionInfo)
     {
         auto ty = QQmlMetaType::qmlType(metaObject);
         QString prototypeName;
@@ -454,24 +453,28 @@ public:
                     && !objectsToMerge->contains(metaObject))
                 objectsToMerge->append(metaObject);
             const QMetaObject *superMetaObject = metaObject->superClass();
-            if (!superMetaObject)
+            if (!superMetaObject) {
                 prototypeName = "QObject";
-            else
+            } else {
+                QQmlType superType = QQmlMetaType::qmlType(superMetaObject);
+                if (superType.isValid() && !superType.isComposite())
+                    return convertToId(superMetaObject->className());
                 prototypeName = getPrototypeNameForCompositeType(
-                            superMetaObject, defaultReachableNames, objectsToMerge, versionInfo);
+                            superMetaObject, objectsToMerge, versionInfo);
+            }
         } else {
             prototypeName = convertToId(metaObject->className());
         }
         return prototypeName;
     }
 
-    void dumpComposite(QQmlEngine *engine, const QList<QQmlType> &compositeType, QSet<QByteArray> &defaultReachableNames,  const QmlVersionInfo &versionInfo)
+    void dumpComposite(QQmlEngine *engine, const QList<QQmlType> &compositeType, const QmlVersionInfo &versionInfo)
     {
         for (const QQmlType &type : compositeType)
-            dumpCompositeItem(engine, type, defaultReachableNames, versionInfo);
+            dumpCompositeItem(engine, type, versionInfo);
     }
 
-    void dumpCompositeItem(QQmlEngine *engine, const QQmlType &compositeType, QSet<QByteArray> &defaultReachableNames, const QmlVersionInfo &versionInfo)
+    void dumpCompositeItem(QQmlEngine *engine, const QQmlType &compositeType, const QmlVersionInfo &versionInfo)
     {
         QQmlComponent e(engine, compositeType.sourceUrl());
         if (!e.isReady()) {
@@ -492,13 +495,17 @@ public:
         QList<const QMetaObject *> objectsToMerge;
         KnownAttributes knownAttributes;
         // Get C++ base class name for the composite type
-        QString prototypeName = getPrototypeNameForCompositeType(mainMeta, defaultReachableNames,
-                                                                 &objectsToMerge, versionInfo);
+        QString prototypeName = getPrototypeNameForCompositeType(mainMeta, &objectsToMerge,
+                                                                 versionInfo);
         qml->writeScriptBinding(QLatin1String("prototype"), enquote(prototypeName));
 
         QString qmlTyName = compositeType.qmlTypeName();
-        const QString exportString = getExportString(qmlTyName, compositeType.majorVersion(), compositeType.minorVersion());
+        const QString exportString = getExportString(compositeType, versionInfo);
+
+        // TODO: why don't we simply output the compositeType.elementName() here?
+        //       That would make more sense, but it would change the format quite a bit.
         qml->writeScriptBinding(QLatin1String("name"), exportString);
+
         qml->writeArrayBinding(QLatin1String("exports"), QStringList() << exportString);
         qml->writeArrayBinding(QLatin1String("exportMetaObjectRevisions"), QStringList() << QString::number(compositeType.minorVersion()));
         qml->writeBooleanBinding(QLatin1String("isComposite"), true);
@@ -565,7 +572,7 @@ public:
                 if (attachedType != meta)
                     attachedTypeId = convertToId(attachedType);
             }
-            const QString exportString = getExportString(type.qmlTypeName(), type.majorVersion(), type.minorVersion());
+            const QString exportString = getExportString(type, { QString(), -1, -1, false });
             int metaObjectRevision = type.metaObjectRevision();
             if (extendedObject) {
                 // emulate custom metaobjectrevision out of import
@@ -1239,9 +1246,6 @@ int main(int argc, char *argv[])
     QSet<const QMetaObject *> uncreatableMetas;
     QSet<const QMetaObject *> singletonMetas;
 
-    // QQuickKeyEvent, QQuickPinchEvent, QQuickDropEvent are not exported
-    QSet<QByteArray> defaultReachableNames;
-
     // this will hold the meta objects we want to dump information of
     QSet<const QMetaObject *> metas;
 
@@ -1370,7 +1374,7 @@ int main(int argc, char *argv[])
 
     QMap<QString, QList<QQmlType>>::const_iterator iter = compositeTypes.constBegin();
     for (; iter != compositeTypes.constEnd(); ++iter)
-        dumper.dumpComposite(&engine, iter.value(), defaultReachableNames, info);
+        dumper.dumpComposite(&engine, iter.value(), info);
 
     // define QEasingCurve as an extension of QQmlEasingValueType, this way
     // properties using the QEasingCurve type get useful type information.
diff --git a/tools/qmlprofiler/qmlprofilerapplication.cpp b/tools/qmlprofiler/qmlprofilerapplication.cpp
index f92ffa9ff..7b010546c 100644
--- a/tools/qmlprofiler/qmlprofilerapplication.cpp
+++ b/tools/qmlprofiler/qmlprofilerapplication.cpp
@@ -302,7 +302,7 @@ void QmlProfilerApplication::flush()
 {
     if (m_recording) {
         m_pendingRequest = REQUEST_FLUSH;
-        m_qmlProfilerClient->sendRecordingStatus(false);
+        m_qmlProfilerClient->setRecording(false);
     } else {
         if (m_profilerData->save(m_interactiveOutputFile)) {
             m_profilerData->clear();
@@ -392,7 +392,7 @@ void QmlProfilerApplication::userCommand(const QString &command)
 
     if (cmd == Constants::CMD_RECORD || cmd == Constants::CMD_RECORD2) {
         m_pendingRequest = REQUEST_TOGGLE_RECORDING;
-        m_qmlProfilerClient->sendRecordingStatus(!m_recording);
+        m_qmlProfilerClient->setRecording(!m_recording);
     } else if (cmd == Constants::CMD_QUIT || cmd == Constants::CMD_QUIT2) {
         m_pendingRequest = REQUEST_QUIT;
         if (m_recording) {
diff --git a/tools/qmlprofiler/qmlprofilerdata.cpp b/tools/qmlprofiler/qmlprofilerdata.cpp
index d5662a018..9ec143975 100644
--- a/tools/qmlprofiler/qmlprofilerdata.cpp
+++ b/tools/qmlprofiler/qmlprofilerdata.cpp
@@ -101,7 +101,6 @@ QmlProfilerData::~QmlProfilerData()
 
 void QmlProfilerData::clear()
 {
-    d->eventTypes.clear();
     d->events.clear();
 
     d->traceEndTime = std::numeric_limits<qint64>::min();
